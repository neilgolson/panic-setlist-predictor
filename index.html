<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panic Setlist Predictor</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Crimson+Pro:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0a0a;
      --bg-card: #1a1a1a;
      --accent-red: #ff3366;
      --accent-orange: #ff8c42;
      --accent-yellow: #ffd93d;
      --text-primary: #f5f5f5;
      --text-secondary: #999;
      --text-muted: #666;
      --border: #333;
      --available: #4ade80;
      --resting: #fbbf24;
      --played: #f87171;
    }

    body {
      font-family: 'Crimson Pro', serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      line-height: 1.6;
      background-image: 
        radial-gradient(circle at 20% 30%, rgba(255, 51, 102, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255, 140, 66, 0.05) 0%, transparent 50%);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      text-align: center;
      margin-bottom: 3rem;
      padding: 2rem 0;
      border-bottom: 2px solid var(--accent-red);
      position: relative;
    }

    h1 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 4rem;
      letter-spacing: 0.1em;
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange), var(--accent-yellow));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
      animation: pulse 3s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    .subtitle {
      font-size: 1.2rem;
      color: var(--text-secondary);
      letter-spacing: 0.05em;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    @media (max-width: 968px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .card h2 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2rem;
      letter-spacing: 0.08em;
      color: var(--accent-orange);
      margin-bottom: 1rem;
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.5rem;
    }

    .input-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    input[type="text"],
    input[type="number"],
    textarea,
    select {
      width: 100%;
      padding: 0.75rem;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      transition: border-color 0.2s;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent-orange);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 51, 102, 0.4);
    }

    .btn-secondary {
      background: var(--bg-dark);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      border-color: var(--accent-orange);
      color: var(--accent-orange);
    }

    .mode-toggle {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .mode-btn {
      flex: 1;
      padding: 0.75rem;
      background: var(--bg-dark);
      border: 2px solid var(--border);
      color: var(--text-secondary);
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1rem;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 6px;
    }

    .mode-btn.active {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      border-color: var(--accent-red);
      color: white;
    }

    .song-list {
      display: grid;
      gap: 0.5rem;
      max-height: 600px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .song-list::-webkit-scrollbar {
      width: 8px;
    }

    .song-list::-webkit-scrollbar-track {
      background: var(--bg-dark);
      border-radius: 4px;
    }

    .song-list::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    .song-list::-webkit-scrollbar-thumb:hover {
      background: var(--accent-orange);
    }

    .song-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-left: 4px solid;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .song-item:hover {
      background: rgba(255, 140, 66, 0.05);
      border-left-color: var(--accent-orange);
    }

    .song-item.available {
      border-left-color: var(--available);
    }

    .song-item.resting {
      border-left-color: var(--resting);
    }

    .song-item.played {
      border-left-color: var(--played);
      opacity: 0.6;
    }

    .song-name {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .song-status {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .status-badge.available {
      background: rgba(74, 222, 128, 0.2);
      color: var(--available);
    }

    .status-badge.resting {
      background: rgba(251, 191, 36, 0.2);
      color: var(--resting);
    }

    .status-badge.played {
      background: rgba(248, 113, 113, 0.2);
      color: var(--played);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .stat-card {
      background: var(--bg-dark);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      text-align: center;
    }

    .stat-value {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2.5rem;
      letter-spacing: 0.05em;
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .search-box {
      margin-bottom: 1rem;
    }

    .search-box input {
      width: 100%;
      padding: 0.75rem 1rem;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 1rem;
    }

    .empty-state {
      text-align: center;
      padding: 3rem 1rem;
      color: var(--text-muted);
    }

    .empty-state-icon {
      font-size: 4rem;
      margin-bottom: 1rem;
    }

    .help-text {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-top: 0.5rem;
      font-style: italic;
    }

    .setlist-display {
      margin-bottom: 1rem;
      padding: 1rem;
      background: var(--bg-dark);
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .setlist-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .setlist-date {
      font-weight: 600;
      color: var(--accent-orange);
    }

    .setlist-songs {
      font-size: 0.9rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .live-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: rgba(74, 222, 128, 0.1);
      border: 1px solid var(--available);
      border-radius: 20px;
      font-size: 0.85rem;
      color: var(--available);
      animation: pulse-live 2s ease-in-out infinite;
    }

    @keyframes pulse-live {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: var(--available);
      border-radius: 50%;
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .quick-add {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .quick-add input {
      flex: 1;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // Heavy rotation / favorite songs (from Apple Music top songs)
    const FAVORITES = [
      "Up All Night",
      "Climb To Safety",
      "Ain't Life Grand",
      "Space Wrangler",
      "Airplane",
      "Driving Song",
      "Pleas",
      "Bear's Gone Fishin'",
      "Chilly Water",
      "Tall Boy",
      "Blue Indian",
      "Disco",
      "Party At Your Mama's House",
      "Little Lilly",
      "Nobody's Loss",
      "Porch Song",
      "Little by Little",
      "The Last Straw",
      "Love Tractor",
      "Hatfield",
      "Papa's Home",
      "Wondering",
      "Blackout Blues",
      "Aunt Avis",
      "Hope In A Hopeless World",
      "C. Brown",
      "Pilgrims",
      "And It Stoned Me",
      "Holden Oversoul",
      "Stop-Go",
      "All Time Low",
      "Travelin' Light",
      "Can't Get High",
      "One Arm Steve",
      "Surprise Valley",
      "Walkin' (For Your Love)",
      "Diner",
      "Jack",
      "Dyin' Man",
      "The Waker",
      "Pickin' Up The Pieces"
    ];

    // Songs with city/location references in lyrics
    const CITY_SONGS = {
      "savannah": ["Red Hot Mama"],
      "athens": ["Coconut", "Space Wrangler"],
      "atlanta": ["Tall Boy", "C. Brown"],
      "memphis": ["Red Hot Mama"],
      "nashville": [],
      "new orleans": ["Papa Johnny Road", "Red Hot Mama"],
      "orleans": ["Papa Johnny Road", "Red Hot Mama"],
      "chicago": [],
      "austin": ["Stop-Go"],
      "san francisco": [],
      "denver": [],
      "boulder": ["Barstools And Dreamers"],
      "colorado": ["Holden Oversoul"],
      "tennessee": ["North", "Up All Night"],
      "georgia": ["Blue Indian", "Coconut"],
      "jackson": ["Action Man"],
      "tallahassee": ["Tall Boy"],
      "miami": [],
      "key west": [],
      "charleston": [],
      "asheville": [],
      "raleigh": [],
      "new york": ["Imitation Leather Shoes", "Sundance"],
      "california": ["Imitation Leather Shoes"],
      "boston": [],
      "texas": [],
      "florida": [],
      "carolina": [],
      "north carolina": [],
      "south carolina": []
    };

    // Default holiday and theme-based songs (based on lyrics and themes)
    const DEFAULT_THEME_SONGS = {
      // Valentine's Day (Feb 10-18)
      valentine: [
        'Love Tractor',
        'Climb To Safety',
        'Walkin\' (For Your Love)',
        'Mercy',
        'Barstools And Dreamers',
        'Who Do You Belong To',
        'Airplane',
        'Tie Your Shoes',
        'Red Hot Mama',
        'Ride Me High',
        'Genesis',
        'Gradle',
        'Diner',
        'Blight',
        'Space Wrangler',
        'Papa\'s Home',
        'Gimme'
      ],
      
      // St. Patrick's Day (Mar 13-21)
      stpatricks: ['Tall Boy', 'Whiskey For Breakfast', 'C. Brown', 'Barstools And Dreamers', 'Papa\'s Home', 'Diner'],
      
      // July 4th (Jun 30 - Jul 8)
      july4th: ['Disco', 'Ain\'t Life Grand', 'Tall Boy', 'C. Brown', 'Party At Your Mama\'s House', 'North'],
      
      // Beach locations (coastal cities within 30mi of ocean)
      beach: ['Fishwater', 'Chilly Water', 'Coconut', 'Arleen', 'Greta', 'Papa Johnny Road'],
      
      // Halloween (Oct 27 - Nov 4)
      halloween: ['Blackout Blues', 'Chainsaw City', 'Dark Bar', 'Jr'],
      
      // Christmas (Dec 21-29)
      christmas: ['Christmas Katie'],
      
      // New Year's (Dec 28 - Jan 4)
      newyear: ['Disco', 'Ain\'t Life Grand', 'Tall Boy', 'C. Brown', 'Party At Your Mama\'s House']
    };

    // Coastal cities within 30 miles of ocean (for beach theme)
    const BEACH_CITIES = [
      // East Coast
      'miami', 'fort lauderdale', 'west palm beach', 'jacksonville', 'st. augustine',
      'savannah', 'charleston', 'myrtle beach', 'wilmington', 'outer banks',
      'virginia beach', 'norfolk', 'ocean city', 'rehoboth', 'atlantic city',
      'asbury park', 'long beach', 'brooklyn', 'queens', 'boston', 'portland',
      'providence', 'newport', 'cape cod',
      // Gulf Coast
      'tampa', 'st. petersburg', 'clearwater', 'sarasota', 'naples', 'fort myers',
      'pensacola', 'panama city', 'destin', 'mobile', 'gulfport', 'biloxi',
      'new orleans', 'galveston', 'corpus christi', 'south padre',
      // West Coast
      'san diego', 'los angeles', 'santa monica', 'malibu', 'santa barbara',
      'san luis obispo', 'monterey', 'santa cruz', 'san francisco', 'oakland',
      'berkeley', 'sausalito', 'portland', 'seattle', 'tacoma',
      // Hawaii & Alaska
      'honolulu', 'maui', 'kauai', 'anchorage', 'juneau'
    ];

    // Get date-based theme for a specific date
    const getDateTheme = (dateString) => {
      const targetDate = dateString ? new Date(dateString + 'T12:00:00') : new Date();
      const month = targetDate.getMonth() + 1;
      const day = targetDate.getDate();
      
      // Helper to check if date is within +/- 4 days of target
      const isWithinRange = (targetMonth, targetDay) => {
        const target = new Date(targetDate.getFullYear(), targetMonth - 1, targetDay);
        const diff = Math.abs(targetDate - target) / (1000 * 60 * 60 * 24); // days
        return diff <= 4;
      };
      
      // Valentine's Day (Feb 14 +/- 4 days = Feb 10-18)
      if (month === 2 && isWithinRange(2, 14)) return 'valentine';
      
      // St. Patrick's Day (Mar 17 +/- 4 days = Mar 13-21)
      if (month === 3 && isWithinRange(3, 17)) return 'stpatricks';
      
      // July 4th (Jul 4 +/- 4 days = Jun 30 - Jul 8)
      if ((month === 6 && day >= 30) || (month === 7 && day <= 8)) return 'july4th';
      
      // Halloween (Oct 31 +/- 4 days = Oct 27 - Nov 4)
      if ((month === 10 && day >= 27) || (month === 11 && day <= 4)) return 'halloween';
      
      // Christmas (Dec 25 +/- 4 days = Dec 21-29)
      if (month === 12 && day >= 21 && day <= 29) return 'christmas';
      
      // New Year's (Jan 1 +/- 4 days = Dec 28 - Jan 5)
      if ((month === 12 && day >= 28) || (month === 1 && day <= 5)) return 'newyear';
      
      return null;
    };

    // Check if city is a beach location (within 30mi of ocean)
    const isBeachCity = (cityString) => {
      if (!cityString) return false;
      const cityLower = cityString.toLowerCase();
      return BEACH_CITIES.some(beach => cityLower.includes(beach));
    };

    // Complete song database from the lyrics file
    const ALL_SONGS = [
      "Chilly Water", "Travelin' Light", "Space Wrangler", "Coconut", "Porch Song",
      "Stop-Go", "Driving Song", "Holden Oversoul", "Contentment Blues", "Me And The Devil Blues",
      "Heaven", "Send Your Mind", "Walkin' (For Your Love)", "Pigeons", "Mercy", "Rock",
      "Makes Sense To Me", "C. Brown", "Love Tractor", "Weight Of The World", "I'm Not Alone",
      "Barstools And Dreamers", "Proving Ground", "The Last Straw", "Pleas", "Hatfield",
      "Wondering", "Papa's Home", "Diner", "Better Off", "Pickin' Up The Pieces",
      "Henry Parsons Died", "Pilgrims", "Postcard", "Dream Song", "Little Kin", "Ain't Life Grand",
      "Airplane", "Can't Get High", "Heroes", "Raise The Roof", "Junior", "Blackout Blues",
      "Jack", "Fishwater", "Radio Child", "Aunt Avis", "Tall Boy", "Gradle", "Glory",
      "Rebirtha", "You Got Yours", "Hope In A Hopeless World", "Greta", "Surprise Valley",
      "Bear's Gone Fishin'", "Climb To Safety", "Blue Indian", "The Waker", "Dyin' Man",
      "You'll Be Fine", "One Arm Steve", "Christmas Katie", "All Time Low", "Nobody's Loss",
      "Fishing", "Thin Air (Smells Like Mississippi)", "Tortured Artist", "Papa Johnny Road",
      "Sparks Fly", "Counting Train Cars", "Don't Wanna Lose You", "Longer Look",
      "Meeting of the Waters", "Nebulous", "Monstrosity", "Time Waits", "Travelin' Man",
      "Second Skin", "Goodpeople", "From The Cradle", "Solid Rock", "Time Zones",
      "When The Clowns Come Home", "Ribs And Whiskey", "Crazy", "You Should Be Glad",
      "May Your Glass Be Filled", "Boom Boom Boom", "Walk On The Flood", "Angels On High",
      "Three Candles", "Tickle The Truth", "Free Somehow", "Flicker", "Dark Day Program",
      "Her Dance Needs No Body", "Already Fried", "Up All Night", "Saint Ex", "North",
      "Dirty Side Down", "This Cruel Thing", "Visiting Day", "Clinic Cynic", "Shut Up And Drive",
      "True To My Nature", "When You Coming Home", "Jaded Tourist", "Cotton Was King"
    ].sort();

    // Common covers and variations (not in official lyrics but played frequently)
    const COMMON_COVERS = [
      "Low Spark Of High Heeled Boys",
      "Bowlegged Woman",
      "Let's Get Down To Business",
      "Sleeping Man",
      "Conrad",
      "Machine",
      "Dark Bar",
      "Party At Your Mama's House",
      "Stop Breakin' Down Blues",
      "Mr. Soul",
      "Little By Little",
      "Walk On",
      "Pleas",
      "There Is A Time",
      "Let's Get The Show On The Road",
      "Sewing Machine",
      "Protein Drink",
      "Bust It Big",
      "We Walk Each Other Home",
      "Don't Be Denied",
      "Down in a Hole",
      "Who Do You Belong To?",
      "Big Wooly Mammoth",
      "King Baby",
      "Sitting In Limbo",
      "I Can See Clearly Now",
      "Paranoid",
      "War Pigs",
      "Disco",
      "Tie Your Shoes",
      "Ride Me High",
      "Little Lilly",
      "Trashy",
      "Lawyers, Guns, And Money",
      "Down",
      "Drums",
      "Jam",
      "Arleen",
      "Smokestack Lightning",
      "Blight",
      "Pusherman",
      "For What It's Worth",
      "Action Man",
      "Good Morning Little Schoolgirl",
      "Chainsaw City",
      "I Walk On Guilded Splinters",
      "I'm So Glad",
      "And It Stoned Me",
      "Red Hot Mama",
      "Spoonful",
      "Maggot Brain",
      "Jack Straw",
      "Blue Carousel",
      "The Take Out"
    ];

    // Fuzzy match song names to handle variations
    const normalizeSongName = (name) => {
      return name
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, '') // Remove special chars
        .replace(/\s+/g, ' ')
        .trim();
    };

    const findSongMatch = (inputSong) => {
      const normalized = normalizeSongName(inputSong);
      
      // Exact match first
      const exactMatch = ALL_SONGS_WITH_COVERS.find(s => 
        normalizeSongName(s) === normalized
      );
      if (exactMatch) return exactMatch;

      // Partial match (contains)
      const partialMatch = ALL_SONGS_WITH_COVERS.find(s =>
        normalizeSongName(s).includes(normalized) || 
        normalized.includes(normalizeSongName(s))
      );
      if (partialMatch) return partialMatch;

      // Return original if no match (will be marked as unknown)
      return inputSong;
    };

    function PanicSetlistPredictor() {
      const [mode, setMode] = useState('setup'); // setup, live, view
      const [setlists, setSetlists] = useState([]);
      const [currentRun, setCurrentRun] = useState(null);
      const [liveSetlist, setLiveSetlist] = useState([]);
      const [searchTerm, setSearchTerm] = useState('');
      const [sortBy, setSortBy] = useState('showsSince'); // 'alpha', 'showsSince', 'status'
      const [newDate, setNewDate] = useState('');
      const [newSongs, setNewSongs] = useState('');
      const [quickAdd, setQuickAdd] = useState('');
      const [isRun, setIsRun] = useState(false);
      const [runDays, setRunDays] = useState(4);
      const [nextRunCity, setNextRunCity] = useState('austin');
      const [editingSetlist, setEditingSetlist] = useState(null); // ID of setlist being edited
      const [unmatchedSongs, setUnmatchedSongs] = useState([]); // Songs that couldn't be matched
      const [customSongs, setCustomSongs] = useState([]); // User-added songs
      const [selectedSongHistory, setSelectedSongHistory] = useState(null); // {song: string, dates: [{date, city}]}
      const [selectedPredictionDetail, setSelectedPredictionDetail] = useState(null); // {show, predictions, actual}
      const [themeSongs, setThemeSongs] = useState(DEFAULT_THEME_SONGS); // Editable theme song lists

      // Combine all available songs (base + covers + custom)
      const ALL_SONGS_WITH_COVERS = useMemo(() => {
        return [...new Set([...ALL_SONGS, ...COMMON_COVERS, ...customSongs])].sort();
      }, [customSongs]);

      // Find song match using fuzzy matching
      const findSongMatch = (inputSong) => {
        const normalized = normalizeSongName(inputSong);
        
        // Exact match first
        const exactMatch = ALL_SONGS_WITH_COVERS.find(s => 
          normalizeSongName(s) === normalized
        );
        if (exactMatch) return exactMatch;

        // Partial match (contains) - but require reasonable length to avoid "Jam" matching "Jamais Vu"
        // Only do substring matching if input is at least 5 chars OR if it's an exact word boundary match
        if (normalized.length >= 5) {
          const partialMatch = ALL_SONGS_WITH_COVERS.find(s =>
            normalizeSongName(s).includes(normalized) || 
            normalized.includes(normalizeSongName(s))
          );
          if (partialMatch) return partialMatch;
        } else {
          // For short inputs (< 5 chars), only match if it's a complete word
          const wordMatch = ALL_SONGS_WITH_COVERS.find(s => {
            const songNormalized = normalizeSongName(s);
            // Split into words and check if input matches any complete word
            const songWords = songNormalized.split(/\s+/);
            return songWords.includes(normalized);
          });
          if (wordMatch) return wordMatch;
        }

        // Return null if no match found
        return null;
      };

      // Load from storage on mount
      useEffect(() => {
        const saved = localStorage.getItem('panicSetlists');
        if (saved) {
          const data = JSON.parse(saved);
          setSetlists(data.setlists || []);
          
          // Auto-detect if run has ended
          let loadedRun = data.currentRun || null;
          if (loadedRun && data.setlists && data.setlists.length > 0) {
            // Sort to get most recent show
            const sortedShows = [...data.setlists].sort((a, b) => new Date(b.date) - new Date(a.date));
            const mostRecentShow = sortedShows[0];
            const mostRecentDate = new Date(mostRecentShow.date);
            const today = new Date();
            
            // Calculate days since most recent show
            const daysSince = Math.floor((today - mostRecentDate) / (1000 * 60 * 60 * 24));
            
            // If more than 1 day since most recent show, the run is over
            if (daysSince > 1) {
              loadedRun = null;
              setIsRun(false);
            }
          }
          
          setCurrentRun(loadedRun);
          setCustomSongs(data.customSongs || []);
          setThemeSongs(data.themeSongs || DEFAULT_THEME_SONGS);
        }
      }, []);

      // Save to storage whenever data changes
      useEffect(() => {
        localStorage.setItem('panicSetlists', JSON.stringify({
          setlists,
          currentRun,
          customSongs,
          themeSongs
        }));
      }, [setlists, currentRun, customSongs, themeSongs]);

      const addSetlist = () => {
        if (!newSongs) return;

        let extractedDate = newDate;
        let extractedCity = currentRun?.city || '';
        let extractedVenue = '';
        let songsText = newSongs;

        // Try to detect Everyday Companion format
        // Format can be:
        // Line 1: MM/DD/YY Venue Name, City, State
        // Line 2: 1: Song1, Song2...
        // OR single line: MM/DD/YY Venue, City, State1: Song1...
        const lines = newSongs.split('\n').map(l => l.trim()).filter(l => l);
        const firstLine = lines[0] || '';
        
        // Check if first line contains a date pattern
        const dateMatch = firstLine.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s+(.+?),\s*([^,]+?)(?:,\s*([A-Z]{2}))?$/);
        
        if (dateMatch) {
          const [fullMatch, month, day, year, venuePart, cityPart, state] = dateMatch;
          
          // Convert date to YYYY-MM-DD format
          const fullYear = year.length === 2 ? `20${year}` : year;
          extractedDate = `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
          
          // Extract venue and city
          if (venuePart) {
            extractedVenue = venuePart.trim();
          }
          
          if (cityPart) {
            extractedCity = cityPart.trim();
            if (state) {
              extractedCity = `${cityPart.trim()}, ${state}`;
            }
          }
          
          // Remove the first line (date/venue/city) from songs text
          songsText = lines.slice(1).join('\n').trim();
        }

        // If still no date, check if user filled it manually
        if (!extractedDate) {
          alert('Please paste a setlist with a date, or enter the date manually.');
          return;
        }

        // Show confirmation dialog with extracted info
        const confirmMessage = `Confirm setlist details:\n\n` +
          `Date: ${extractedDate}\n` +
          `${extractedVenue ? `Venue: ${extractedVenue}\n` : ''}` +
          `${extractedCity ? `City: ${extractedCity}\n` : ''}` +
          `\nProceed with adding this setlist?`;
        
        if (!confirm(confirmMessage)) {
          return;
        }

        const rawSongs = songsText
          .split(/[,\n>]/)  // Also split on > for segues
          .map(s => s.trim())
          .filter(s => s.length > 0)
          // Remove set markers from beginning of song names (e.g., "1: Song" -> "Song", "E1: Song" -> "Song")
          .map(s => s.replace(/^(1|2|3|E\d?):\s*/, '').trim())
          // Remove trailing set markers from song names (e.g., "Song1:" -> "Song")
          .map(s => s.replace(/\d+:$/, '').trim())
          // Remove asterisks at end
          .map(s => s.replace(/\*+$/, '').trim())
          // Filter out standalone set markers if they somehow remain
          .filter(s => !s.match(/^(1|2|3|E\d?):?$/))
          .filter(s => !['Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          // Remove city/state patterns (e.g., "Milwaukee", "WI", "Milwaukee, WI")
          .filter(s => {
            // Skip if it's just a city or state abbreviation
            if (extractedCity && extractedCity.toLowerCase().includes(s.toLowerCase())) {
              return false;
            }
            // Skip if it's just a 2-letter state code
            if (s.match(/^[A-Z]{2}$/)) {
              return false;
            }
            // Skip if it looks like just a city name (single word, capitalized)
            if (s.match(/^[A-Z][a-z]+$/) && extractedCity && extractedCity.includes(s)) {
              return false;
            }
            return true;
          })
          // Filter out empty strings after all processing
          .filter(s => s.length > 0);

        // Try to match each song
        const matchedSongs = [];
        const unmatched = [];
        
        rawSongs.forEach(rawSong => {
          const matched = findSongMatch(rawSong);
          if (matched) {
            matchedSongs.push(matched);
          } else {
            unmatched.push(rawSong);
          }
        });

        // If there are unmatched songs, show them to the user
        if (unmatched.length > 0) {
          setUnmatchedSongs(unmatched);
          // Store extracted data for later use
          setNewDate(extractedDate);
          if (extractedCity) {
            setCurrentRun({ days: runDays, city: extractedCity });
            setIsRun(true);
          }
          // Don't add the setlist yet - wait for user to review unmatched songs
          return;
        }

        // Create and add the setlist
        const newSetlist = {
          date: extractedDate,
          songs: matchedSongs,
          city: extractedCity,
          venue: extractedVenue,
          id: Date.now()
        };

        // Add and sort by date (newest first)
        setSetlists(prev => {
          const updated = [newSetlist, ...prev];
          const sorted = updated.sort((a, b) => new Date(b.date) - new Date(a.date));
          
          // Auto-detect runs: check if consecutive shows have the same city
          if (sorted.length >= 2 && newSetlist.city) {
            let consecutiveSameCity = 1;
            for (let i = 1; i < sorted.length; i++) {
              if (sorted[i].city && sorted[i].city.toLowerCase() === newSetlist.city.toLowerCase()) {
                consecutiveSameCity++;
              } else {
                break;
              }
            }
            
            // If 2+ consecutive shows in same city, enable run mode
            if (consecutiveSameCity >= 2) {
              setCurrentRun({ days: consecutiveSameCity, city: newSetlist.city });
              setIsRun(true);
              setRunDays(consecutiveSameCity);
            }
          }
          
          return sorted;
        });
        setNewDate('');
        setNewSongs('');
      };

      const addUnmatchedSongsAndContinue = () => {
        // Add unmatched songs to custom songs list
        setCustomSongs(prev => [...prev, ...unmatchedSongs]);
        
        // Now process the setlist with all songs (including newly added ones)
        const allSongs = newSongs
          .split(/[,\n>]/)
          .map(s => s.trim())
          .filter(s => s.length > 0)
          .filter(s => !['1:', '2:', '3:', 'E:', 'Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          .map(s => s.replace(/\*+$/, '').trim())
          .map(rawSong => {
            // Try to match in updated list
            const allAvailable = [...ALL_SONGS, ...COMMON_COVERS, ...customSongs, ...unmatchedSongs];
            return allAvailable.find(song => 
              normalizeSongName(song) === normalizeSongName(rawSong) ||
              normalizeSongName(song).includes(normalizeSongName(rawSong)) ||
              normalizeSongName(rawSong).includes(normalizeSongName(song))
            ) || rawSong; // Use raw name if still no match
          });

        const newSetlist = {
          date: newDate,
          songs: allSongs,
          city: currentRun?.city || '',
          id: Date.now()
        };

        setSetlists(prev => {
          const updated = [newSetlist, ...prev];
          const sorted = updated.sort((a, b) => new Date(b.date) - new Date(a.date));
          
          if (sorted.length >= 2 && newSetlist.city) {
            let consecutiveSameCity = 1;
            for (let i = 1; i < sorted.length; i++) {
              if (sorted[i].city && sorted[i].city.toLowerCase() === newSetlist.city.toLowerCase()) {
                consecutiveSameCity++;
              } else {
                break;
              }
            }
            
            if (consecutiveSameCity >= 2) {
              setCurrentRun({ days: consecutiveSameCity, city: newSetlist.city });
              setIsRun(true);
              setRunDays(consecutiveSameCity);
            }
          }
          
          return sorted;
        });

        setUnmatchedSongs([]);
        setNewDate('');
        setNewSongs('');
      };

      const skipUnmatchedAndContinue = () => {
        // Process setlist without unmatched songs
        const matchedSongs = newSongs
          .split(/[,\n>]/)
          .map(s => s.trim())
          .filter(s => s.length > 0)
          .filter(s => !['1:', '2:', '3:', 'E:', 'Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          .map(s => s.replace(/\*+$/, '').trim())
          .map(findSongMatch)
          .filter(s => s); // Remove nulls

        const newSetlist = {
          date: newDate,
          songs: matchedSongs,
          city: currentRun?.city || '',
          id: Date.now()
        };

        setSetlists(prev => {
          const updated = [newSetlist, ...prev];
          const sorted = updated.sort((a, b) => new Date(b.date) - new Date(a.date));
          
          if (sorted.length >= 2 && newSetlist.city) {
            let consecutiveSameCity = 1;
            for (let i = 1; i < sorted.length; i++) {
              if (sorted[i].city && sorted[i].city.toLowerCase() === newSetlist.city.toLowerCase()) {
                consecutiveSameCity++;
              } else {
                break;
              }
            }
            
            if (consecutiveSameCity >= 2) {
              setCurrentRun({ days: consecutiveSameCity, city: newSetlist.city });
              setIsRun(true);
              setRunDays(consecutiveSameCity);
            }
          }
          
          return sorted;
        });

        setUnmatchedSongs([]);
        setNewDate('');
        setNewSongs('');
      };

      const deleteSetlist = (id) => {
        setSetlists(prev => prev.filter(s => s.id !== id));
      };

      const showSongHistory = (songName) => {
        // Find all shows where this song was played
        const playedShows = setlists
          .filter(setlist => setlist.songs.includes(songName))
          .map(setlist => ({
            date: setlist.date,
            city: setlist.city || '',
            songs: setlist.songs // Include for debugging
          }))
          .sort((a, b) => new Date(b.date) - new Date(a.date)); // Most recent first

        console.log(`Song history for "${songName}":`, playedShows);
        console.log('All setlists:', setlists);
        
        setSelectedSongHistory({
          song: songName,
          dates: playedShows
        });
      };

      const startEditingSetlist = (setlist) => {
        setEditingSetlist(setlist.id);
        setNewDate(setlist.date);
        setNewSongs(setlist.songs.join(', '));
        if (setlist.city) {
          setCurrentRun({ days: runDays, city: setlist.city });
          setIsRun(true);
        }
      };

      const saveEditedSetlist = () => {
        if (!editingSetlist || !newDate || !newSongs) return;

        const songs = newSongs
          .split(/[,\n>]/)
          .map(s => s.trim())
          .filter(s => s.length > 0)
          .filter(s => !['1:', '2:', '3:', 'E:', 'Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          .map(s => s.replace(/\*+$/, '').trim())
          .map(findSongMatch);

        setSetlists(prev => {
          const updated = prev.map(s => {
            if (s.id === editingSetlist) {
              return {
                ...s,
                date: newDate,
                songs: songs,
                city: currentRun?.city || ''
              };
            }
            return s;
          });
          return updated.sort((a, b) => new Date(b.date) - new Date(a.date));
        });

        // Clear edit mode
        setEditingSetlist(null);
        setNewDate('');
        setNewSongs('');
        setIsRun(false);
        setCurrentRun(null);
      };

      const cancelEdit = () => {
        setEditingSetlist(null);
        setNewDate('');
        setNewSongs('');
        setIsRun(false);
        setCurrentRun(null);
      };

      const startLiveMode = () => {
        setMode('live');
        setLiveSetlist([]);
      };

      const addSongToLive = (song) => {
        if (!liveSetlist.includes(song)) {
          setLiveSetlist(prev => [...prev, song]);
        }
        setQuickAdd('');
      };

      const removeSongFromLive = (song) => {
        setLiveSetlist(prev => prev.filter(s => s !== song));
      };

      const saveLiveSetlist = () => {
        if (liveSetlist.length === 0) return;
        
        const today = new Date().toISOString().split('T')[0];
        const newSetlist = {
          date: today,
          songs: liveSetlist,
          id: Date.now()
        };

        setSetlists(prev => [newSetlist, ...prev].slice(0, 10));
        setLiveSetlist([]);
        setMode('view');
      };

      // Calculate song availability based on 3-show rule
      const songStatus = useMemo(() => {
        const status = {};
        
        // Initialize all songs as available
        ALL_SONGS_WITH_COVERS.forEach(song => {
          status[song] = {
            available: true,
            lastPlayed: null,
            showsSince: Infinity,
            inCurrentRun: false,
            timesPlayed: 0,
            playFrequency: 0
          };
        });

        // Sort setlists by date (newest first) for consistent processing
        const sortedSetlists = [...setlists].sort((a, b) => new Date(b.date) - new Date(a.date));

        // Count total plays for each song (deduplicate within each setlist)
        sortedSetlists.forEach(setlist => {
          const uniqueSongs = [...new Set(setlist.songs)];
          uniqueSongs.forEach(song => {
            if (status[song]) {
              status[song].timesPlayed++;
            }
          });
        });

        // Calculate play frequency
        const totalShows = sortedSetlists.length;
        if (totalShows > 0) {
          ALL_SONGS_WITH_COVERS.forEach(song => {
            if (status[song]) {
              status[song].playFrequency = (status[song].timesPlayed / totalShows) * 100;
            }
          });
        }

        // Apply 3-show rule - process all shows to find when each song was last played
        sortedSetlists.forEach((setlist, index) => {
          setlist.songs.forEach(song => {
            if (status[song]) {
              // Only set the FIRST time we see this song (most recent since sorted newest first)
              if (status[song].showsSince === Infinity) {
                status[song].showsSince = index;
                status[song].lastPlayed = setlist.date;
                status[song].available = (index >= 3);
              }
            }
          });
        });

        // Factor in live setlist - only in live mode
        if (mode === 'live' && liveSetlist.length > 0) {
          liveSetlist.forEach(song => {
            if (status[song]) {
              status[song].available = false;
              status[song].lastPlayed = 'Tonight';
              status[song].showsSince = 0;
            }
          });
        }

        return status;
      }, [setlists, mode, liveSetlist]);

      // Calculate top 20 most frequently played songs from the database (must be after songStatus)
      const heavyRotation = useMemo(() => {
        // Recalculate play counts fresh from setlists
        const playCounts = {};
        
        setlists.forEach(setlist => {
          // Deduplicate songs in each setlist to prevent counting duplicates
          const uniqueSongs = [...new Set(setlist.songs)];
          uniqueSongs.forEach(song => {
            // Exclude instrumental segments
            if (song === 'Drums' || song === 'Jam') return;
            playCounts[song] = (playCounts[song] || 0) + 1;
          });
        });
        
        // Convert to array and sort by play count (descending - most played first)
        const sortedSongs = Object.entries(playCounts)
          .filter(([song, count]) => count >= 3) // Minimum 3 plays for Heavy Rotation
          .sort((a, b) => {
            const countA = a[1];
            const countB = b[1];
            
            // Sort by play count descending (most played at top)
            if (countB > countA) return 1;  // b has more plays, so b comes first
            if (countB < countA) return -1; // a has more plays, so a comes first
            
            // If tie, alphabetical
            return a[0].localeCompare(b[0]);
          })
          .slice(0, 20) // Top 20
          .map(([song]) => song);
        
        return sortedSongs;
      }, [setlists]);

      const filteredSongs = useMemo(() => {
        let songs = ALL_SONGS_WITH_COVERS.filter(song => 
          song.toLowerCase().includes(searchTerm.toLowerCase())
        );

        // Sort based on selected option
        if (sortBy === 'showsSince') {
          songs.sort((a, b) => {
            const aStatus = songStatus[a];
            const bStatus = songStatus[b];
            
            // Priority 1: Songs that have been played AND are available (not in last 3)
            const aPlayedAndAvailable = aStatus.lastPlayed && aStatus.showsSince > 2;
            const bPlayedAndAvailable = bStatus.lastPlayed && bStatus.showsSince > 2;
            
            // Priority 2: Songs currently resting (played in last 3)
            const aResting = aStatus.showsSince >= 0 && aStatus.showsSince <= 2;
            const bResting = bStatus.showsSince >= 0 && bStatus.showsSince <= 2;
            
            // Priority 3: Never played (showsSince === Infinity, no lastPlayed)
            const aNeverPlayed = aStatus.showsSince === Infinity && !aStatus.lastPlayed;
            const bNeverPlayed = bStatus.showsSince === Infinity && !bStatus.lastPlayed;
            
            // Top priority: Played but available (longer time since = higher)
            if (aPlayedAndAvailable && !bPlayedAndAvailable) return -1;
            if (!aPlayedAndAvailable && bPlayedAndAvailable) return 1;
            if (aPlayedAndAvailable && bPlayedAndAvailable) {
              // Among available, sort by longest time since played
              if (bStatus.showsSince !== aStatus.showsSince) {
                return bStatus.showsSince - aStatus.showsSince;
              }
              return a.localeCompare(b);
            }
            
            // Middle priority: Resting songs
            if (aResting && !bResting) return -1;
            if (!aResting && bResting) return 1;
            if (aResting && bResting) {
              // Among resting, sort by shows since (furthest from availability first)
              if (bStatus.showsSince !== aStatus.showsSince) {
                return bStatus.showsSince - aStatus.showsSince;
              }
              return a.localeCompare(b);
            }
            
            // Bottom priority: Never played
            if (aNeverPlayed && !bNeverPlayed) return 1;
            if (!aNeverPlayed && bNeverPlayed) return -1;
            if (aNeverPlayed && bNeverPlayed) {
              return a.localeCompare(b);
            }
            
            return a.localeCompare(b);
          });
        } else if (sortBy === 'status') {
          songs.sort((a, b) => {
            const aStatus = songStatus[a];
            const bStatus = songStatus[b];
            
            // Available first, then resting, then played
            if (aStatus.available && !bStatus.available) return -1;
            if (!aStatus.available && bStatus.available) return 1;
            if (!aStatus.available && !bStatus.available) {
              if (aStatus.showsSince !== bStatus.showsSince) {
                return bStatus.showsSince - aStatus.showsSince;
              }
            }
            return a.localeCompare(b);
          });
        } else {
          // Alphabetical
          songs.sort();
        }

        return songs;
      }, [searchTerm, sortBy, songStatus]);

      const stats = useMemo(() => {
        const available = Object.values(songStatus).filter(s => s.available).length;
        const resting = Object.values(songStatus).filter(s => !s.available && s.showsSince > 0).length;
        const played = Object.values(songStatus).filter(s => s.showsSince === 0).length;
        
        return { available, resting, played, total: ALL_SONGS_WITH_COVERS.length };
      }, [songStatus]);

      // Calculate accuracy for each show with 20+ shows of history
      const showAccuracy = useMemo(() => {
        const sortedSetlists = [...setlists].sort((a, b) => new Date(a.date) - new Date(b.date));
        const accuracyMap = {};
        
        sortedSetlists.forEach((targetSetlist, targetIndex) => {
          // Need at least 20 shows of history
          if (targetIndex < 20) {
            accuracyMap[targetSetlist.id] = null;
            return;
          }
          
          // Get history (all shows before this one)
          const historySetlists = sortedSetlists.slice(0, targetIndex);
          
          // Build songStatus from history
          const historySongStatus = {};
          ALL_SONGS_WITH_COVERS.forEach(song => {
            historySongStatus[song] = {
              available: true,
              lastPlayed: null,
              showsSince: Infinity,
              timesPlayed: 0,
              playFrequency: 0
            };
          });
          
          // Count plays
          historySetlists.forEach(setlist => {
            const uniqueSongs = [...new Set(setlist.songs)];
            uniqueSongs.forEach(song => {
              if (historySongStatus[song]) {
                historySongStatus[song].timesPlayed++;
              }
            });
          });
          
          // Calculate frequency
          const totalHistoryShows = historySetlists.length;
          ALL_SONGS_WITH_COVERS.forEach(song => {
            if (historySongStatus[song]) {
              historySongStatus[song].playFrequency = 
                (historySongStatus[song].timesPlayed / totalHistoryShows) * 100;
            }
          });
          
          // Apply 3-show rule
          const reversedHistory = [...historySetlists].reverse();
          reversedHistory.forEach((setlist, reverseIndex) => {
            const forwardIndex = historySetlists.length - 1 - reverseIndex;
            setlist.songs.forEach(song => {
              if (historySongStatus[song] && historySongStatus[song].showsSince === Infinity) {
                historySongStatus[song].showsSince = forwardIndex;
                historySongStatus[song].lastPlayed = setlist.date;
                historySongStatus[song].available = (forwardIndex >= 3);
              }
            });
          });
          
          // Calculate Heavy Rotation
          const historyHeavyRotation = Object.entries(historySongStatus)
            .filter(([song, status]) => status.timesPlayed >= 3)
            .sort((a, b) => b[1].timesPlayed - a[1].timesPlayed || a[0].localeCompare(b[0]))
            .slice(0, 20)
            .map(([song]) => song);
          
          // Run prediction algorithm
          const predictions = Object.entries(historySongStatus)
            .filter(([song, status]) => {
              if (song === 'Drums' || song === 'Jam') return false;
              if (status.timesPlayed < 2) return false;
              return status.available || status.showsSince === 2;
            })
            .map(([song, status]) => {
              let score = 0;
              score += status.playFrequency * 0.5;
              if (historyHeavyRotation.includes(song)) score += 30;
              if (status.showsSince !== Infinity) score += Math.min(20, status.showsSince * 2);
              
              const cityMatches = historySetlists.some(s => 
                s.city && targetSetlist.city && 
                s.city.toLowerCase() === targetSetlist.city.toLowerCase() && 
                s.songs.includes(song)
              );
              if (cityMatches) score += 30;
              
              const theme = getDateTheme(targetSetlist.date);
              let themeList = theme ? (themeSongs[theme] || []) : [];
              if (isBeachCity(targetSetlist.city)) {
                themeList = [...themeList, ...(themeSongs['beach'] || [])];
              }
              if (themeList.includes(song)) score += 30;
              
              return { song, score };
            })
            .sort((a, b) => b.score - a.score)
            .slice(0, 10)
            .map(p => p.song);
          
          // Check accuracy
          const actualSongs = [...new Set(targetSetlist.songs)];
          const matches = actualSongs.filter(song => predictions.includes(song));
          
          accuracyMap[targetSetlist.id] = {
            matches: matches.length,
            totalPredicted: 10,
            totalPlayed: actualSongs.length,
            predictionAccuracy: ((matches.length / 10) * 100).toFixed(0), // How many of our top 10 were correct
            coverage: ((matches.length / actualSongs.length) * 100).toFixed(0), // What % of their setlist we predicted
            predictions: predictions, // Store the actual predictions
            actualSongs: actualSongs, // Store the actual songs played
            matchedSongs: matches // Store which songs matched
          };
        });
        
        return accuracyMap;
      }, [setlists, themeSongs, ALL_SONGS_WITH_COVERS]);

      return (
        <div className="container">
          {/* Unmatched Songs Modal */}
          {unmatchedSongs.length > 0 && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.8)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '2rem'
            }}>
              <div style={{
                background: 'var(--bg-card)',
                border: '2px solid var(--accent-orange)',
                borderRadius: '12px',
                padding: '2rem',
                maxWidth: '600px',
                width: '100%',
                maxHeight: '80vh',
                overflow: 'auto'
              }}>
                <h2 style={{ color: 'var(--accent-orange)', marginBottom: '1rem' }}>
                   Unmatched Songs Found
                </h2>
                <p style={{ marginBottom: '1rem', color: 'var(--text-secondary)' }}>
                  The following songs couldn't be matched to the database. They might be:
                </p>
                <ul style={{ marginBottom: '1rem', color: 'var(--text-secondary)', paddingLeft: '1.5rem' }}>
                  <li>New covers or originals not in the database</li>
                  <li>Typos or misspellings</li>
                  <li>Song name variations</li>
                </ul>
                
                <div style={{
                  background: 'var(--bg-dark)',
                  padding: '1rem',
                  borderRadius: '6px',
                  marginBottom: '1.5rem',
                  maxHeight: '300px',
                  overflow: 'auto'
                }}>
                  {unmatchedSongs.map((song, i) => (
                    <div key={i} style={{
                      padding: '0.5rem',
                      borderBottom: i < unmatchedSongs.length - 1 ? '1px solid var(--border)' : 'none',
                      color: 'var(--text-primary)'
                    }}>
                       {song}
                    </div>
                  ))}
                </div>

                <p style={{ marginBottom: '1.5rem', fontSize: '0.9rem', color: 'var(--text-muted)' }}>
                  What would you like to do?
                </p>

                <div style={{ display: 'flex', gap: '0.5rem', flexDirection: 'column' }}>
                  <button 
                    className="btn btn-primary"
                    onClick={addUnmatchedSongsAndContinue}
                    style={{ width: '100%' }}
                  >
                     Add These Songs to Database
                  </button>
                  <button 
                    className="btn btn-secondary"
                    onClick={skipUnmatchedAndContinue}
                    style={{ width: '100%' }}
                  >
                    Skip These Songs
                  </button>
                  <button 
                    className="btn btn-secondary"
                    onClick={() => setUnmatchedSongs([])}
                    style={{ width: '100%' }}
                  >
                    Cancel (Go Back and Fix)
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Song History Modal */}
          {selectedSongHistory && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.8)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '2rem'
            }}>
              <div style={{
                background: 'var(--bg-card)',
                border: '2px solid var(--accent-yellow)',
                borderRadius: '12px',
                padding: '2rem',
                maxWidth: '600px',
                width: '100%',
                maxHeight: '80vh',
                overflow: 'auto'
              }}>
                <h2 style={{ color: 'var(--accent-yellow)', marginBottom: '0.5rem' }}>
                  {selectedSongHistory.song}
                </h2>
                <div style={{ 
                  fontSize: '0.9rem', 
                  color: 'var(--text-secondary)',
                  marginBottom: '1.5rem'
                }}>
                  Played {selectedSongHistory.dates.length} time{selectedSongHistory.dates.length !== 1 ? 's' : ''}
                </div>
                
                <div style={{
                  background: 'var(--bg-dark)',
                  padding: '1rem',
                  borderRadius: '6px',
                  maxHeight: '400px',
                  overflow: 'auto'
                }}>
                  {selectedSongHistory.dates.length === 0 ? (
                    <div style={{ 
                      color: 'var(--text-muted)', 
                      fontStyle: 'italic',
                      textAlign: 'center',
                      padding: '1rem'
                    }}>
                      Never played in your setlist history
                    </div>
                  ) : (
                    selectedSongHistory.dates.map((show, i) => (
                      <div key={i} style={{
                        padding: '0.75rem',
                        borderBottom: i < selectedSongHistory.dates.length - 1 ? '1px solid var(--border)' : 'none',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center'
                      }}>
                        <div>
                          <div style={{ color: 'var(--text-primary)', fontWeight: '500' }}>
                            {(() => {
                              // Parse date as local time to avoid timezone shifts
                              const [year, month, day] = show.date.split('-');
                              return `${month}/${day}/${year.slice(-2)}`;
                            })()}
                          </div>
                          {show.city && (
                            <div style={{ 
                              fontSize: '0.85rem', 
                              color: 'var(--text-muted)',
                              marginTop: '0.25rem'
                            }}>
                               {show.city}
                            </div>
                          )}
                        </div>
                      </div>
                    ))
                  )}
                </div>

                <button 
                  className="btn btn-secondary"
                  onClick={() => setSelectedSongHistory(null)}
                  style={{ width: '100%', marginTop: '1.5rem' }}
                >
                  Close
                </button>
              </div>
            </div>
          )}

          {/* Prediction Detail Modal */}
          {selectedPredictionDetail && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.8)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '2rem'
            }}>
              <div style={{
                background: 'var(--bg-card)',
                border: '2px solid var(--accent-purple)',
                borderRadius: '12px',
                padding: '2rem',
                maxWidth: '900px',
                width: '100%',
                maxHeight: '80vh',
                overflow: 'auto'
              }}>
                <h2 style={{ color: 'var(--accent-purple)', marginBottom: '0.5rem' }}>
                   Prediction Analysis
                </h2>
                <div style={{ 
                  fontSize: '0.9rem', 
                  color: 'var(--text-secondary)',
                  marginBottom: '1.5rem'
                }}>
                  {selectedPredictionDetail.date}  {selectedPredictionDetail.city}
                </div>
                
                <div style={{
                  display: 'grid',
                  gridTemplateColumns: '1fr 1fr',
                  gap: '1.5rem',
                  marginBottom: '1.5rem'
                }}>
                  {/* Predictions Column */}
                  <div>
                    <h3 style={{ 
                      color: 'var(--text-primary)', 
                      marginBottom: '0.75rem',
                      fontSize: '1rem',
                      borderBottom: '2px solid var(--accent-purple)',
                      paddingBottom: '0.5rem'
                    }}>
                      Top 10 Predictions
                    </h3>
                    <div style={{
                      background: 'var(--bg-dark)',
                      padding: '1rem',
                      borderRadius: '6px'
                    }}>
                      {selectedPredictionDetail.predictions.map((song, i) => {
                        const wasPlayed = selectedPredictionDetail.matchedSongs.includes(song);
                        return (
                          <div key={i} style={{
                            padding: '0.5rem',
                            marginBottom: '0.25rem',
                            background: wasPlayed ? 'rgba(34, 197, 94, 0.2)' : 'transparent',
                            border: wasPlayed ? '1px solid rgb(34, 197, 94)' : '1px solid transparent',
                            borderRadius: '4px',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.5rem'
                          }}>
                            <span style={{ 
                              color: 'var(--text-muted)', 
                              fontSize: '0.8rem',
                              minWidth: '1.5rem'
                            }}>
                              {i + 1}.
                            </span>
                            <span style={{ 
                              color: wasPlayed ? 'rgb(34, 197, 94)' : 'var(--text-primary)',
                              fontWeight: wasPlayed ? '600' : 'normal'
                            }}>
                              {song}
                            </span>
                            {wasPlayed && (
                              <span style={{ marginLeft: 'auto', fontSize: '0.9rem' }}></span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </div>

                  {/* Actual Setlist Column */}
                  <div>
                    <h3 style={{ 
                      color: 'var(--text-primary)', 
                      marginBottom: '0.75rem',
                      fontSize: '1rem',
                      borderBottom: '2px solid var(--accent-orange)',
                      paddingBottom: '0.5rem'
                    }}>
                      Actual Setlist ({selectedPredictionDetail.actualSongs.length} songs)
                    </h3>
                    <div style={{
                      background: 'var(--bg-dark)',
                      padding: '1rem',
                      borderRadius: '6px',
                      maxHeight: '400px',
                      overflow: 'auto'
                    }}>
                      {selectedPredictionDetail.actualSongs.map((song, i) => {
                        const wasPredicted = selectedPredictionDetail.matchedSongs.includes(song);
                        return (
                          <div key={i} style={{
                            padding: '0.5rem',
                            marginBottom: '0.25rem',
                            background: wasPredicted ? 'rgba(34, 197, 94, 0.2)' : 'transparent',
                            border: wasPredicted ? '1px solid rgb(34, 197, 94)' : '1px solid transparent',
                            borderRadius: '4px',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.5rem'
                          }}>
                            <span style={{ 
                              color: wasPredicted ? 'rgb(34, 197, 94)' : 'var(--text-primary)',
                              fontWeight: wasPredicted ? '600' : 'normal'
                            }}>
                              {song}
                            </span>
                            {wasPredicted && (
                              <span style={{ marginLeft: 'auto', fontSize: '0.9rem' }}></span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>

                <div style={{
                  padding: '1rem',
                  background: selectedPredictionDetail.accuracy >= 50 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                  border: `1px solid ${selectedPredictionDetail.accuracy >= 50 ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)'}`,
                  borderRadius: '6px',
                  marginBottom: '1.5rem',
                  textAlign: 'center'
                }}>
                  <div style={{ fontSize: '2rem', marginBottom: '0.25rem' }}>
                    {selectedPredictionDetail.matches}/10
                  </div>
                  <div style={{ 
                    color: 'var(--text-secondary)',
                    fontSize: '0.9rem'
                  }}>
                    {selectedPredictionDetail.accuracy}% Prediction Accuracy
                  </div>
                </div>

                <button 
                  className="btn btn-secondary"
                  onClick={() => setSelectedPredictionDetail(null)}
                  style={{ width: '100%' }}
                >
                  Close
                </button>
              </div>
            </div>
          )}

          <header>
            <h1>Panic Setlist Predictor</h1>
            <p className="subtitle">Track the 3-show rule  Predict available songs  Live updates</p>
          </header>

          {/* Next Run Prediction Box */}
          <div className="card" style={{ 
            marginBottom: '2rem',
            background: 'linear-gradient(135deg, rgba(255, 51, 102, 0.1), rgba(255, 140, 66, 0.1))',
            borderColor: 'var(--accent-orange)'
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
              <h2 style={{ color: 'var(--accent-red)', margin: 0 }}> Next Run Prediction</h2>
              {(() => {
                const upcomingDate = '2026-02-14';
                const theme = getDateTheme(upcomingDate);
                const isBeach = isBeachCity(nextRunCity);
                if (!theme && !isBeach) return null;
                
                const themeLabels = {
                  valentine: { emoji: '', label: 'Valentine\'s Day', color: 'rgb(147, 51, 234)' },
                  stpatricks: { emoji: '', label: 'St. Patrick\'s Day', color: 'rgb(34, 197, 94)' },
                  july4th: { emoji: '', label: 'July 4th', color: 'rgb(239, 68, 68)' },
                  beach: { emoji: '', label: 'Beach Vibes', color: 'rgb(14, 165, 233)' },
                  halloween: { emoji: '', label: 'Halloween', color: 'rgb(249, 115, 22)' },
                  christmas: { emoji: '', label: 'Christmas', color: 'rgb(22, 163, 74)' },
                  newyear: { emoji: '', label: 'New Year\'s', color: 'rgb(234, 179, 8)' }
                };
                
                const themeInfo = theme ? themeLabels[theme] : (isBeach ? themeLabels['beach'] : null);
                if (!themeInfo) return null;
                
                return (
                  <div style={{
                    padding: '0.5rem 1rem',
                    background: `${themeInfo.color}15`,
                    border: `1px solid ${themeInfo.color}`,
                    borderRadius: '6px',
                    fontSize: '0.85rem',
                    fontWeight: '500',
                    color: themeInfo.color,
                    whiteSpace: 'nowrap'
                  }}>
                    {themeInfo.emoji} {themeInfo.label}
                  </div>
                );
              })()}
            </div>
            <div style={{ display: 'grid', gridTemplateColumns: '2fr 3fr', gap: '2rem', alignItems: 'start' }}>
              <div>
                <div style={{ marginBottom: '1rem' }}>
                  <div style={{ 
                    fontSize: '1.8rem', 
                    fontFamily: "'Bebas Neue', sans-serif",
                    letterSpacing: '0.05em',
                    color: 'var(--accent-orange)',
                    marginBottom: '0.25rem'
                  }}>
                    February 14-15, 2026
                  </div>
                  <div style={{ fontSize: '1.2rem', color: 'var(--text-secondary)' }}>
                     Moody Center, Austin, TX
                  </div>
                  <div style={{ 
                    fontSize: '0.9rem', 
                    color: 'var(--text-muted)',
                    marginTop: '0.5rem',
                    fontStyle: 'italic'
                  }}>
                    2-night run
                  </div>
                </div>
                
                <div style={{ marginTop: '1.5rem', paddingTop: '1.5rem', borderTop: '1px solid var(--border)' }}>
                  <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                    <label style={{ fontSize: '0.85rem', marginBottom: '0.25rem' }}>City/Location</label>
                    <input 
                      type="text"
                      placeholder="e.g., Savannah, Austin..."
                      value={nextRunCity}
                      onChange={e => setNextRunCity(e.target.value)}
                      style={{ 
                        width: '100%',
                        padding: '0.5rem',
                        background: 'var(--bg-dark)',
                        border: '1px solid var(--border)',
                        borderRadius: '6px',
                        color: 'var(--text-primary)',
                        fontSize: '0.9rem'
                      }}
                    />
                  </div>
                </div>
              </div>
              
              <div>
                <h3 style={{ 
                  fontSize: '1rem',
                  color: 'var(--text-secondary)',
                  marginBottom: '0.75rem',
                  textTransform: 'uppercase',
                  letterSpacing: '0.1em'
                }}>
                  Top 10 Most Likely Songs
                </h3>
                <div style={{ 
                  display: 'grid', 
                  gridTemplateColumns: '1fr 1fr',
                  gap: '0.5rem',
                  fontSize: '0.95rem'
                }}>
                  {(() => {
                    const upcomingCity = nextRunCity.toLowerCase().trim();
                    const upcomingDate = '2026-02-14'; // First night of the run
                    const runNights = 2; // 2-night run
                    
                    console.log('=== PREDICTION CALCULATION ===');
                    console.log('Total songs in songStatus:', Object.keys(songStatus).length);
                    
                    // Calculate likelihood score for each song
                    // Include songs available on EITHER night of the run
                    const scoredSongs = Object.entries(songStatus)
                      .filter(([song, status]) => {
                        const isInstrumental = song === 'Drums' || song === 'Jam';
                        const hasEnoughPlays = status.timesPlayed >= 2;
                        const availableNight1 = status.available;
                        const availableNight2 = status.showsSince === 2;
                        const passesFilter = !isInstrumental && hasEnoughPlays && (availableNight1 || availableNight2);
                        
                        if (song === 'Climb To Safety') {
                          console.log('Climb To Safety filter check:', {
                            isInstrumental,
                            timesPlayed: status.timesPlayed,
                            hasEnoughPlays,
                            showsSince: status.showsSince,
                            available: status.available,
                            availableNight1,
                            availableNight2,
                            passesFilter
                          });
                        }
                        
                        return passesFilter;
                      })
                      .map(([song, status]) => {
                        let score = 0;
                        
                        // Determine which night(s) this song is available
                        const availableNight1 = status.available;
                        const availableNight2 = status.showsSince === 2; // Currently resting (2 shows), becomes available on Night 2
                        const nightsAvailable = availableNight1 ? 'both' : 'night2';
                        
                        // Debug logging for songs that should be Night 2
                        if (song === 'Climb To Safety') {
                          console.log('Climb To Safety:', {
                            showsSince: status.showsSince,
                            available: status.available,
                            availableNight1,
                            availableNight2,
                            nightsAvailable,
                            timesPlayed: status.timesPlayed
                          });
                        }
                        
                        // Factor 1: Play frequency (0-50 points)
                        score += status.playFrequency * 0.5;
                        
                        // Factor 2: Favorite status (0-30 points)
                        if (heavyRotation.includes(song)) {
                          score += 30;
                        }
                        
                        // Factor 3: Time since last played (0-20 points)
                        if (status.showsSince !== Infinity) {
                          score += Math.min(20, status.showsSince * 2);
                        }
                        
                        // Factor 4: City-specific bonus (0-30 points)
                        const citySongs = CITY_SONGS[upcomingCity] || [];
                        const isCitySong = citySongs.includes(song);
                        if (isCitySong) {
                          score += 30;
                        }
                        
                        // Factor 5: Holiday/Theme bonus (0-30 points)
                        const currentTheme = getDateTheme(upcomingDate);
                        let themeList = currentTheme ? (themeSongs[currentTheme] || []) : [];
                        
                        // Also check for beach location bonus
                        if (isBeachCity(nextRunCity)) {
                          themeList = [...themeList, ...(themeSongs['beach'] || [])];
                        }
                        
                        const isThemeSong = themeList.includes(song);
                        if (isThemeSong) {
                          score += 30;
                        }
                        
                        // Factor 6: Night 2 availability bonus (0-15 points)
                        // Boost songs that become available on Night 2 so they appear in predictions
                        if (nightsAvailable === 'night2') {
                          score += 15;
                        }
                        
                        // RECALCULATE actual times played from setlists directly
                        const actualTimesPlayed = setlists.filter(setlist => 
                          setlist.songs.includes(song)
                        ).length;
                        
                        return { 
                          song, 
                          score, 
                          status: { ...status, timesPlayed: actualTimesPlayed }, 
                          isCity: isCitySong,
                          isTheme: isThemeSong,
                          theme: currentTheme,
                          nightsAvailable: nightsAvailable
                        };
                      })
                      .sort((a, b) => {
                        // First, sort by night availability (Night 1/both before Night 2)
                        if (a.nightsAvailable === 'both' && b.nightsAvailable === 'night2') return -1;
                        if (a.nightsAvailable === 'night2' && b.nightsAvailable === 'both') return 1;
                        
                        // Then by score
                        return b.score - a.score;
                      })
                      .slice(0, 10);
                    
                    console.log('Final top 10:', scoredSongs.map(s => ({ 
                      song: s.song, 
                      score: s.score, 
                      nights: s.nightsAvailable,
                      showsSince: s.status.showsSince 
                    })));
                    console.log('Night 2 songs:', scoredSongs.filter(s => s.nightsAvailable === 'night2').map(s => s.song));

                    if (scoredSongs.length === 0) {
                      return (
                        <div style={{ 
                          gridColumn: '1 / -1',
                          color: 'var(--text-muted)', 
                          fontSize: '0.9rem',
                          fontStyle: 'italic',
                          padding: '1rem'
                        }}>
                          Add some setlists to see predictions!
                        </div>
                      );
                    }

                    return scoredSongs.map(({ song, status, isCity, isTheme, theme, nightsAvailable }, i) => {
                      // Format last played date to MM/DD/YY
                      let lastPlayedFormatted = '';
                      if (status.lastPlayed && status.lastPlayed !== 'Tonight') {
                        // Parse date as local time to avoid timezone shifts
                        const [year, month, day] = status.lastPlayed.split('-');
                        lastPlayedFormatted = `${month}/${day}/${year.slice(-2)}`;
                      }

                      // Determine background color and border
                      let bgColor = 'var(--bg-dark)';
                      let borderColor = 'var(--accent-yellow)';
                      let icon = '';
                      
                      if (isTheme) {
                        bgColor = 'rgba(147, 51, 234, 0.15)'; // Purple for theme songs
                        borderColor = 'rgb(147, 51, 234)';
                        icon = theme === 'valentine' ? '' : 
                               theme === 'stpatricks' ? '' :
                               theme === 'july4th' ? '' :
                               theme === 'halloween' ? '' :
                               theme === 'christmas' ? '' :
                               theme === 'newyear' ? '' : '';
                      } else if (isCity) {
                        bgColor = 'rgba(255, 140, 66, 0.15)'; // Orange for city songs
                        borderColor = 'var(--accent-orange)';
                        icon = '';
                      }

                      return (
                        <div key={i} style={{ 
                          padding: '0.5rem 0.75rem',
                          background: bgColor,
                          borderRadius: '6px',
                          borderLeft: `3px solid ${borderColor}`,
                          fontSize: '0.85rem',
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          gap: '0.5rem',
                          cursor: 'pointer',
                          transition: 'transform 0.1s ease'
                        }}
                        onClick={() => showSongHistory(song)}
                        onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.02)'}
                        onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}
                        >
                          <span style={{ flex: 1, minWidth: 0 }}>
                            {song}
                            {icon && <span style={{ marginLeft: '0.25rem' }}>{icon}</span>}
                            {nightsAvailable === 'night2' && (
                              <span style={{ 
                                marginLeft: '0.5rem',
                                fontSize: '0.65rem',
                                color: 'var(--accent-orange)',
                                fontWeight: '500'
                              }}>
                                N2
                              </span>
                            )}
                          </span>
                          <span style={{ 
                            fontSize: '0.7rem', 
                            color: 'var(--text-muted)',
                            fontStyle: 'italic',
                            whiteSpace: 'nowrap'
                          }}>
                            {lastPlayedFormatted || 'Never'}
                          </span>
                          <span style={{ 
                            fontSize: '0.7rem', 
                            color: 'var(--text-muted)',
                            whiteSpace: 'nowrap'
                          }}>
                            {Math.floor(status.timesPlayed)}x
                          </span>
                        </div>
                      );
                    });
                  })()}
                </div>
              </div>
            </div>
          </div>

          <div className="main-grid">
            {/* Left Column - Controls */}
            <div>
              <div className="card">
                <h2>Mode</h2>
                <div className="mode-toggle">
                  <button 
                    className={`mode-btn ${mode === 'setup' ? 'active' : ''}`}
                    onClick={() => setMode('setup')}
                  >
                    Setup
                  </button>
                  <button 
                    className={`mode-btn ${mode === 'live' ? 'active' : ''}`}
                    onClick={startLiveMode}
                  >
                    Live Show
                  </button>
                  <button 
                    className={`mode-btn ${mode === 'view' ? 'active' : ''}`}
                    onClick={() => setMode('view')}
                  >
                    View Songs
                  </button>
                </div>

                {mode === 'setup' && (
                  <>
                    {editingSetlist && (
                      <div style={{ 
                        padding: '1rem', 
                        background: 'rgba(255, 140, 66, 0.1)', 
                        borderRadius: '6px',
                        marginBottom: '1rem',
                        border: '1px solid var(--accent-orange)'
                      }}>
                        <div style={{ fontSize: '0.9rem', color: 'var(--accent-orange)', marginBottom: '0.5rem' }}>
                           Editing Setlist
                        </div>
                      </div>
                    )}

                    <div className="input-group">
                      <label>Paste Setlist (Everyday Companion format supported)</label>
                      <textarea 
                        placeholder="Paste entire setlist from Everyday Companion or enter songs manually...
Example:
11/23/25 Fox Theater - Boulder, CO
Chilly Water, Pigeons, Space Wrangler..."
                        value={newSongs}
                        onChange={e => setNewSongs(e.target.value)}
                        style={{ minHeight: '200px' }}
                      />
                      <div className="help-text">
                        Paste from Everyday Companion (with date/venue) or type songs manually
                      </div>
                    </div>

                    {editingSetlist ? (
                      <div style={{ display: 'flex', gap: '0.5rem' }}>
                        <button className="btn btn-primary" onClick={saveEditedSetlist} style={{ flex: 1 }}>
                          Save Changes
                        </button>
                        <button className="btn btn-secondary" onClick={cancelEdit} style={{ flex: 1 }}>
                          Cancel
                        </button>
                      </div>
                    ) : (
                      <button className="btn btn-primary" onClick={addSetlist}>
                        Parse & Add Setlist
                      </button>
                    )}
                  </>
                )}

                {mode === 'live' && (
                  <>
                    <div className="live-indicator">
                      <span className="live-dot"></span>
                      Live Show in Progress
                    </div>

                    <div className="quick-add">
                      <input 
                        type="text"
                        placeholder="Add song to tonight's setlist..."
                        value={quickAdd}
                        onChange={e => setQuickAdd(e.target.value)}
                        onKeyPress={e => {
                          if (e.key === 'Enter' && quickAdd) {
                            const match = ALL_SONGS_WITH_COVERS.find(s => 
                              normalizeSongName(s).includes(normalizeSongName(quickAdd))
                            );
                            if (match) addSongToLive(match);
                          }
                        }}
                      />
                      <button 
                        className="btn btn-primary"
                        onClick={() => {
                          const match = ALL_SONGS_WITH_COVERS.find(s => 
                            normalizeSongName(s).includes(normalizeSongName(quickAdd))
                          );
                          if (match) addSongToLive(match);
                        }}
                      >
                        Add
                      </button>
                    </div>

                    <div style={{ marginBottom: '1rem' }}>
                      <strong>Tonight's Setlist ({liveSetlist.length} songs):</strong>
                      {liveSetlist.length > 0 ? (
                        <div style={{ marginTop: '0.5rem', fontSize: '0.9rem' }}>
                          {liveSetlist.map((song, i) => (
                            <div key={i} style={{ display: 'flex', justifyContent: 'space-between', padding: '0.25rem 0', borderBottom: '1px solid var(--border)' }}>
                              <span>{song}</span>
                              <button 
                                onClick={() => removeSongFromLive(song)}
                                style={{ background: 'none', border: 'none', color: 'var(--played)', cursor: 'pointer' }}
                              >
                                
                              </button>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <div style={{ color: 'var(--text-muted)', fontSize: '0.9rem', marginTop: '0.5rem' }}>
                          No songs added yet
                        </div>
                      )}
                    </div>

                    <button className="btn btn-primary" onClick={saveLiveSetlist}>
                      Save Tonight's Setlist
                    </button>
                    <button className="btn btn-secondary" onClick={() => setLiveSetlist([])}>
                      Clear
                    </button>
                  </>
                )}
              </div>

              {/* Recent Setlists - Last 4 */}
              <div className="card" style={{ marginTop: '2rem' }}>
                <h2>Recent Shows</h2>
                {setlists.length === 0 ? (
                  <div className="empty-state">
                    <div className="empty-state-icon"></div>
                    <p>No setlists yet</p>
                    <p style={{ fontSize: '0.85rem' }}>Add your first show to get started</p>
                  </div>
                ) : (
                  <div>
                    {[...setlists]
                      .sort((a, b) => new Date(b.date) - new Date(a.date))
                      .slice(0, 4) // Only show last 4
                      .map((setlist, index) => {
                        return (
                          <div key={setlist.id} className="setlist-display">
                            <div className="setlist-header">
                              <span className="setlist-date">
                                {setlist.date}
                                {setlist.city && (
                                  <span style={{ marginLeft: '0.5rem', color: 'var(--accent-orange)' }}>
                                     {setlist.city}
                                  </span>
                                )}
                              </span>
                            </div>
                            <div className="setlist-songs">
                              {setlist.songs.join(', ')}
                            </div>
                          </div>
                        );
                      })}
                  </div>
                )}
              </div>
            </div>

            {/* Right Column - Song List */}
            <div>
              <div className="card">
                <h2>Song Availability</h2>
                
                <div className="stats-grid">
                  <div className="stat-card">
                    <div className="stat-value">{stats.available}</div>
                    <div className="stat-label">Available</div>
                  </div>
                  <div className="stat-card">
                    <div className="stat-value">{stats.resting}</div>
                    <div className="stat-label">Resting</div>
                  </div>
                  <div className="stat-card">
                    <div className="stat-value">{stats.played}</div>
                    <div className="stat-label">Recently Played</div>
                  </div>
                </div>

                {/* Heavy Rotation Section - Top 20 Most Played */}
                {!searchTerm && heavyRotation.length > 0 && (
                  <>
                    <h3 style={{ 
                      fontFamily: "'Bebas Neue', sans-serif",
                      fontSize: '1.5rem',
                      color: 'var(--accent-yellow)',
                      marginBottom: '0.5rem',
                      borderBottom: '1px solid var(--border)',
                      paddingBottom: '0.5rem'
                    }}>
                      Heavy Rotation
                    </h3>
                    <div style={{ 
                      fontSize: '0.8rem', 
                      color: 'var(--text-muted)', 
                      marginBottom: '0.5rem',
                      fontStyle: 'italic'
                    }}>
                      Songs played 3+ times (Top 20 most frequently played)
                    </div>
                    <div className="song-list" style={{ maxHeight: '300px', marginBottom: '1.5rem' }}>
                      {heavyRotation.map(song => {
                        const status = songStatus[song];
                        if (!status) return null;
                        const statusClass = status.available ? 'available' : 
                                           status.showsSince === 0 ? 'played' : 'resting';
                        
                        return (
                          <div 
                            key={song} 
                            className={`song-item ${statusClass}`}
                            onClick={() => {
                              if (mode === 'live' && status.available) {
                                addSongToLive(song);
                              } else {
                                showSongHistory(song);
                              }
                            }}
                            style={{ cursor: 'pointer' }}
                          >
                            <span className="song-name">{song}</span>
                            <div className="song-status">
                              {status.available ? (
                                <>
                                  <span className="status-badge available">Available</span>
                                  {status.lastPlayed && status.showsSince !== Infinity && (
                                    <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                      {status.showsSince} shows ago
                                    </span>
                                  )}
                                </>
                              ) : status.inCurrentRun ? (
                                <span className="status-badge resting">In Run</span>
                              ) : status.lastPlayed === 'Tonight' ? (
                                <span className="status-badge played">Tonight</span>
                              ) : status.showsSince === 0 ? (
                                <span className="status-badge played">Most Recent</span>
                              ) : status.showsSince === Infinity ? (
                                <span className="status-badge available">Never Played</span>
                              ) : (
                                <span className="status-badge resting">
                                  {status.showsSince === 1 ? '1 show ago' : 
                                   status.showsSince === 2 ? '2 shows ago' : 
                                   `${status.showsSince} shows ago`}
                                </span>
                              )}
                              {status.lastPlayed && status.lastPlayed !== 'Tonight' && (
                                <span style={{ fontSize: '0.75rem' }}>{status.lastPlayed}</span>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </>
                )}

                {/* Sort By - First */}
                <div className="input-group" style={{ marginBottom: '1rem' }}>
                  <label>Sort By</label>
                  <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
                    <option value="showsSince">Shows Since Last Played</option>
                    <option value="status">Availability Status</option>
                    <option value="alpha">Alphabetical</option>
                  </select>
                </div>

                {/* Search Box - Second */}
                <div className="search-box">
                  <input 
                    type="text"
                    placeholder=" Search songs..."
                    value={searchTerm}
                    onChange={e => setSearchTerm(e.target.value)}
                  />
                </div>

                <h3 style={{ 
                  fontFamily: "'Bebas Neue', sans-serif",
                  fontSize: '1.5rem',
                  color: 'var(--text-secondary)',
                  marginBottom: '0.5rem',
                  borderBottom: '1px solid var(--border)',
                  paddingBottom: '0.5rem'
                }}>
                  All Songs
                </h3>

                <div className="song-list">
                  {filteredSongs.map(song => {
                    const status = songStatus[song];
                    if (!status) return null;
                    const statusClass = status.available ? 'available' : 
                                       status.showsSince === 0 ? 'played' : 'resting';
                    
                    return (
                      <div 
                        key={song} 
                        className={`song-item ${statusClass}`}
                        onClick={() => {
                          if (mode === 'live' && status.available) {
                            addSongToLive(song);
                          } else {
                            showSongHistory(song);
                          }
                        }}
                        style={{ cursor: 'pointer' }}
                      >
                        <span className="song-name">{song}</span>
                        <div className="song-status">
                          {status.available ? (
                            <>
                              <span className="status-badge available">Available</span>
                              {status.lastPlayed && status.showsSince !== Infinity && (
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                  {status.showsSince} shows ago
                                </span>
                              )}
                            </>
                          ) : status.inCurrentRun ? (
                            <span className="status-badge resting">In Run</span>
                          ) : status.lastPlayed === 'Tonight' ? (
                            <span className="status-badge played">Tonight</span>
                          ) : status.showsSince === 0 ? (
                            <span className="status-badge played">Most Recent</span>
                          ) : status.showsSince === Infinity ? (
                            <span className="status-badge available">Never Played</span>
                          ) : (
                            <span className="status-badge resting">
                              {status.showsSince === 1 ? '1 show ago' : 
                               status.showsSince === 2 ? '2 shows ago' : 
                               `${status.showsSince} shows ago`}
                            </span>
                          )}
                          {status.timesPlayed > 0 && (
                            <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                              {status.timesPlayed}x played
                            </span>
                          )}
                          {status.lastPlayed && status.lastPlayed !== 'Tonight' && (
                            <span style={{ fontSize: '0.75rem' }}>{status.lastPlayed}</span>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* All Shows Section */}
              <div className="card" style={{ marginTop: '2rem' }}>
                <h2>All Shows ({setlists.length})</h2>
                {setlists.length === 0 ? (
                  <div className="empty-state">
                    <div className="empty-state-icon"></div>
                    <p>No setlists yet</p>
                    <p style={{ fontSize: '0.85rem' }}>Add your first show to get started</p>
                  </div>
                ) : (
                  <div style={{ maxHeight: '600px', overflow: 'auto' }}>
                    {[...setlists]
                      .sort((a, b) => new Date(b.date) - new Date(a.date))
                      .map((setlist, index) => {
                        const isEditing = editingSetlist === setlist.id;
                        
                        return (
                          <div key={setlist.id} className="setlist-display" style={{
                            background: isEditing ? 'rgba(255, 140, 66, 0.1)' : 'var(--bg-dark)',
                            border: isEditing ? '1px solid var(--accent-orange)' : '1px solid var(--border)'
                          }}>
                            {isEditing ? (
                              // Edit mode
                              <div>
                                <div style={{ marginBottom: '1rem', color: 'var(--accent-orange)', fontSize: '0.9rem' }}>
                                   Editing Setlist
                                </div>
                                <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                                  <label>Date</label>
                                  <input 
                                    type="date" 
                                    value={newDate}
                                    onChange={e => setNewDate(e.target.value)}
                                  />
                                </div>
                                <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                                  <label>Songs (comma-separated)</label>
                                  <textarea 
                                    value={newSongs}
                                    onChange={e => setNewSongs(e.target.value)}
                                    style={{ minHeight: '100px' }}
                                  />
                                </div>
                                <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                                  <label>City/Location (optional)</label>
                                  <input 
                                    type="text"
                                    value={currentRun?.city || ''}
                                    onChange={e => setCurrentRun({ ...currentRun, city: e.target.value })}
                                    placeholder="e.g., Atlanta, GA"
                                  />
                                </div>
                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                  <button className="btn btn-primary" onClick={saveEditedSetlist} style={{ flex: 1 }}>
                                    Save Changes
                                  </button>
                                  <button className="btn btn-secondary" onClick={cancelEdit} style={{ flex: 1 }}>
                                    Cancel
                                  </button>
                                </div>
                              </div>
                            ) : (
                              // Display mode
                              <>
                                <div className="setlist-header">
                                  <span className="setlist-date">
                                    {setlist.date}
                                    {setlist.city && (
                                      <span style={{ marginLeft: '0.5rem', color: 'var(--accent-orange)' }}>
                                         {setlist.city}
                                      </span>
                                    )}
                                    {showAccuracy[setlist.id] && (
                                      <span 
                                        onClick={() => {
                                          setSelectedPredictionDetail({
                                            date: setlist.date,
                                            city: setlist.city || 'Unknown',
                                            predictions: showAccuracy[setlist.id].predictions,
                                            actualSongs: showAccuracy[setlist.id].actualSongs,
                                            matchedSongs: showAccuracy[setlist.id].matchedSongs,
                                            matches: showAccuracy[setlist.id].matches,
                                            accuracy: showAccuracy[setlist.id].predictionAccuracy
                                          });
                                        }}
                                        style={{ 
                                        marginLeft: '0.75rem',
                                        padding: '0.25rem 0.5rem',
                                        background: showAccuracy[setlist.id].predictionAccuracy >= 50 ? 'rgba(34, 197, 94, 0.2)' : 'rgba(239, 68, 68, 0.2)',
                                        border: `1px solid ${showAccuracy[setlist.id].predictionAccuracy >= 50 ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)'}`,
                                        borderRadius: '4px',
                                        fontSize: '0.75rem',
                                        fontWeight: '600',
                                        color: showAccuracy[setlist.id].predictionAccuracy >= 50 ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)',
                                        cursor: 'pointer',
                                        transition: 'transform 0.1s ease'
                                      }}
                                      onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
                                      onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}
                                      >
                                         {showAccuracy[setlist.id].matches}/10 ({showAccuracy[setlist.id].predictionAccuracy}%)
                                      </span>
                                    )}
                                  </span>
                                  <div style={{ display: 'flex', gap: '0.5rem' }}>
                                    <button 
                                      className="btn btn-secondary" 
                                      style={{ padding: '0.25rem 0.75rem', fontSize: '0.85rem' }}
                                      onClick={() => startEditingSetlist(setlist)}
                                    >
                                      Edit
                                    </button>
                                    <button 
                                      className="btn btn-secondary" 
                                      style={{ padding: '0.25rem 0.75rem', fontSize: '0.85rem' }}
                                      onClick={() => deleteSetlist(setlist.id)}
                                    >
                                      Delete
                                    </button>
                                  </div>
                                </div>
                                <div className="setlist-songs">
                                  {setlist.songs.join(', ')}
                                </div>
                              </>
                            )}
                          </div>
                        );
                      })}
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Theme Songs Editor */}
          <div style={{ 
            marginTop: '4rem', 
            paddingTop: '2rem', 
            borderTop: '2px solid var(--accent-purple)'
          }}>
            <h2 style={{
              fontFamily: "'Bebas Neue', sans-serif",
              fontSize: '2rem',
              color: 'var(--accent-purple)',
              marginBottom: '1rem',
              textAlign: 'center'
            }}>
               Theme Song Lists
            </h2>
            <p style={{
              textAlign: 'center',
              color: 'var(--text-muted)',
              marginBottom: '2rem',
              fontSize: '0.9rem'
            }}>
              Customize which songs get bonuses for each holiday or theme
            </p>

            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
              gap: '1.5rem'
            }}>
              {Object.entries({
                valentine: { emoji: '', label: 'Valentine\'s Day', color: 'rgb(147, 51, 234)', dateRange: 'Feb 10-18' },
                stpatricks: { emoji: '', label: 'St. Patrick\'s Day', color: 'rgb(34, 197, 94)', dateRange: 'Mar 13-21' },
                july4th: { emoji: '', label: 'July 4th', color: 'rgb(239, 68, 68)', dateRange: 'Jun 30 - Jul 8' },
                beach: { emoji: '', label: 'Beach', color: 'rgb(14, 165, 233)', dateRange: 'Coastal cities only' },
                halloween: { emoji: '', label: 'Halloween', color: 'rgb(249, 115, 22)', dateRange: 'Oct 27 - Nov 4' },
                christmas: { emoji: '', label: 'Christmas', color: 'rgb(22, 163, 74)', dateRange: 'Dec 21-29' },
                newyear: { emoji: '', label: 'New Year\'s', color: 'rgb(234, 179, 8)', dateRange: 'Dec 28 - Jan 5' }
              }).map(([themeKey, themeInfo]) => (
                <div key={themeKey} style={{
                  background: 'var(--bg-dark)',
                  border: `2px solid ${themeInfo.color}`,
                  borderRadius: '12px',
                  padding: '1.5rem'
                }}>
                  <h3 style={{
                    color: themeInfo.color,
                    marginBottom: '0.5rem',
                    fontSize: '1.2rem',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.5rem'
                  }}>
                    <span style={{ fontSize: '1.5rem' }}>{themeInfo.emoji}</span>
                    {themeInfo.label}
                  </h3>
                  <div style={{
                    fontSize: '0.75rem',
                    color: 'var(--text-muted)',
                    marginBottom: '1rem',
                    fontStyle: 'italic'
                  }}>
                    {themeInfo.dateRange}
                  </div>
                  
                  <textarea
                    value={(themeSongs[themeKey] || []).join(', ')}
                    onChange={(e) => {
                      const songs = e.target.value
                        .split(',')
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                      setThemeSongs({
                        ...themeSongs,
                        [themeKey]: songs
                      });
                    }}
                    style={{
                      width: '100%',
                      minHeight: '120px',
                      background: 'var(--bg-light)',
                      border: '1px solid var(--border)',
                      borderRadius: '6px',
                      padding: '0.75rem',
                      color: 'var(--text-primary)',
                      fontFamily: 'inherit',
                      fontSize: '0.85rem',
                      resize: 'vertical'
                    }}
                    placeholder="Song 1, Song 2, Song 3..."
                  />
                  
                  <div style={{
                    marginTop: '0.75rem',
                    fontSize: '0.75rem',
                    color: 'var(--text-muted)',
                    fontStyle: 'italic'
                  }}>
                    {(themeSongs[themeKey] || []).length} songs  Comma-separated
                  </div>
                  
                  <button
                    className="btn btn-secondary"
                    onClick={() => {
                      if (confirm(`Reset ${themeInfo.label} to default list?`)) {
                        setThemeSongs({
                          ...themeSongs,
                          [themeKey]: DEFAULT_THEME_SONGS[themeKey]
                        });
                      }
                    }}
                    style={{
                      marginTop: '0.75rem',
                      width: '100%',
                      padding: '0.5rem',
                      fontSize: '0.85rem'
                    }}
                  >
                    Reset to Default
                  </button>
                </div>
              ))}
            </div>
          </div>

          {/* Data Management - Bottom of Page */}
          <div style={{ 
            marginTop: '4rem', 
            paddingTop: '2rem', 
            borderTop: '1px solid var(--border)',
            textAlign: 'center',
            display: 'flex',
            gap: '1rem',
            justifyContent: 'center',
            flexWrap: 'wrap'
          }}>
            <button 
              className="btn btn-primary"
              onClick={() => {
                // Show all dates with show counts
                const dateMap = {};
                setlists.forEach(setlist => {
                  const date = setlist.date;
                  if (!dateMap[date]) {
                    dateMap[date] = { count: 0, setlists: [] };
                  }
                  dateMap[date].count++;
                  dateMap[date].setlists.push(setlist);
                });
                
                const dates = Object.keys(dateMap).sort().reverse();
                let message = ' ALL SHOW DATES IN DATABASE:\n\n';
                dates.forEach(date => {
                  const info = dateMap[date];
                  message += `${date} - ${info.count} setlist${info.count > 1 ? 's' : ''}\n`;
                  if (info.count > 1) {
                    message += `   DUPLICATE! (${info.setlists.map(s => s.id).join(', ')})\n`;
                  }
                });
                
                alert(message);
              }}
              style={{ 
                background: '#0369a1', 
                borderColor: '#075985',
                padding: '0.75rem 2rem'
              }}
            >
               Show All Dates
            </button>
            
            <button 
              className="btn btn-primary"
              onClick={() => {
                // Comprehensive export for analysis
                const exportData = {
                  exportDate: new Date().toISOString(),
                  totalShows: setlists.length,
                  setlists: [...setlists].sort((a, b) => new Date(a.date) - new Date(b.date)).map(s => ({
                    id: s.id,
                    date: s.date,
                    city: s.city || '',
                    venue: s.venue || '',
                    songs: s.songs
                  })),
                  themeSongs: themeSongs,
                  accuracyScores: Object.entries(showAccuracy)
                    .filter(([id, acc]) => acc !== null)
                    .map(([id, acc]) => {
                      const setlist = setlists.find(s => s.id === parseInt(id));
                      return {
                        showId: id,
                        date: setlist?.date,
                        city: setlist?.city,
                        matches: acc.matches,
                        totalPredicted: acc.totalPredicted,
                        totalPlayed: acc.totalPlayed,
                        predictionAccuracy: parseFloat(acc.predictionAccuracy),
                        coverage: parseFloat(acc.coverage)
                      };
                    }),
                  overallStats: {
                    totalAnalyzedShows: Object.values(showAccuracy).filter(a => a !== null).length,
                    totalCorrect: Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.matches, 0),
                    totalPredictions: Object.values(showAccuracy).filter(a => a !== null).length * 10,
                    totalPlayed: Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.totalPlayed, 0),
                    overallPredictionAccuracy: (Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.matches, 0) / 
                                               (Object.values(showAccuracy).filter(a => a !== null).length * 10) * 100).toFixed(2),
                    overallCoverage: (Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.matches, 0) / 
                                     Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.totalPlayed, 0) * 100).toFixed(2)
                  }
                };
                
                // Download as JSON
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `panic-data-export-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                
                alert(` Data Export Complete!\n\n` +
                      `Total Shows: ${exportData.totalShows}\n` +
                      `Analyzed Shows: ${exportData.overallStats.totalAnalyzedShows}\n` +
                      `Prediction Accuracy: ${exportData.overallStats.overallPredictionAccuracy}% (correct/10)\n` +
                      `Coverage: ${exportData.overallStats.overallCoverage}% (of total setlist)\n\n` +
                      `File downloaded as JSON for analysis.`);
              }}
              style={{ 
                background: '#7c3aed', 
                borderColor: '#6d28d9',
                padding: '0.75rem 2rem'
              }}
            >
               Export Data for Analysis
            </button>
            
            <button 
              className="btn btn-primary"
              onClick={() => {
                if (confirm(' Fix Data Issues\n\nThis will:\n- Remove duplicate songs from each setlist\n- Clean up any corrupted data\n- Keep all your setlists intact\n\nContinue?')) {
                  // Fix each setlist by deduplicating songs
                  const fixedSetlists = setlists.map(setlist => ({
                    ...setlist,
                    songs: [...new Set(setlist.songs)] // Remove duplicates
                  }));
                  
                  // Count how many songs were removed
                  const before = setlists.reduce((sum, s) => sum + s.songs.length, 0);
                  const after = fixedSetlists.reduce((sum, s) => sum + s.songs.length, 0);
                  const removed = before - after;
                  
                  setSetlists(fixedSetlists);
                  alert(` Data fixed!\n\nRemoved ${removed} duplicate song entries from your setlists.\n\nYour play counts should now be accurate.`);
                }
              }}
              style={{ 
                background: '#059669', 
                borderColor: '#047857',
                padding: '0.75rem 2rem'
              }}
            >
               Fix Duplicate Songs
            </button>
            
            <button 
              className="btn btn-secondary"
              onClick={() => {
                if (confirm(' DANGER ZONE \n\nThis will permanently delete ALL setlists, custom songs, and settings. This action cannot be undone.\n\nAre you absolutely sure?')) {
                  setSetlists([]);
                  setLiveSetlist([]);
                  setCustomSongs([]);
                  setEditingSetlist(null);
                  localStorage.clear();
                  alert('All data has been reset.');
                }
              }}
              style={{ 
                background: '#991b1b', 
                borderColor: '#7f1d1d',
                padding: '0.75rem 2rem'
              }}
            >
               Reset All Data
            </button>
          </div>
          <div style={{ 
            fontSize: '0.75rem', 
            color: 'var(--text-muted)', 
            marginTop: '0.5rem',
            textAlign: 'center',
            fontStyle: 'italic'
          }}>
            Fix duplicates first  Reset deletes everything permanently
          </div>
        </div>
      );
    }

    ReactDOM.render(<PanicSetlistPredictor />, document.getElementById('root'));
  </script>
</body>
</html>
