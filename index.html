<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panic Setlist Predictor</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Crimson+Pro:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0a0a;
      --bg-card: #1a1a1a;
      --accent-red: #ff3366;
      --accent-orange: #ff8c42;
      --accent-yellow: #ffd93d;
      --text-primary: #f5f5f5;
      --text-secondary: #999;
      --text-muted: #666;
      --border: #333;
      --available: #4ade80;
      --resting: #fbbf24;
      --played: #f87171;
    }

    body {
      font-family: 'Crimson Pro', serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      line-height: 1.6;
      background-image: 
        radial-gradient(circle at 20% 30%, rgba(255, 51, 102, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255, 140, 66, 0.05) 0%, transparent 50%);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    header {
      text-align: center;
      margin-bottom: 3rem;
      padding: 2rem 0;
      border-bottom: 2px solid var(--accent-red);
      position: relative;
    }

    h1 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 4rem;
      letter-spacing: 0.1em;
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange), var(--accent-yellow));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
      animation: pulse 3s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    .subtitle {
      font-size: 1.2rem;
      color: var(--text-secondary);
      letter-spacing: 0.05em;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    @media (max-width: 968px) {
      .main-grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .card h2 {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2rem;
      letter-spacing: 0.08em;
      color: var(--accent-orange);
      margin-bottom: 1rem;
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.5rem;
    }

    .input-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    input[type="text"],
    input[type="number"],
    textarea,
    select {
      width: 100%;
      padding: 0.75rem;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'Crimson Pro', serif;
      font-size: 1rem;
      transition: border-color 0.2s;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent-orange);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 51, 102, 0.4);
    }

    .btn-secondary {
      background: var(--bg-dark);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      border-color: var(--accent-orange);
      color: var(--accent-orange);
    }

    .mode-toggle {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .mode-btn {
      flex: 1;
      padding: 0.75rem;
      background: var(--bg-dark);
      border: 2px solid var(--border);
      color: var(--text-secondary);
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1rem;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 6px;
    }

    .mode-btn.active {
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      border-color: var(--accent-red);
      color: white;
    }

    .song-list {
      display: grid;
      gap: 0.5rem;
      max-height: 600px;
      overflow-y: auto;
      padding-right: 0.5rem;
    }

    .song-list::-webkit-scrollbar {
      width: 8px;
    }

    .song-list::-webkit-scrollbar-track {
      background: var(--bg-dark);
      border-radius: 4px;
    }

    .song-list::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    .song-list::-webkit-scrollbar-thumb:hover {
      background: var(--accent-orange);
    }

    .song-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-left: 4px solid;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .song-item:hover {
      background: rgba(255, 140, 66, 0.05);
      border-left-color: var(--accent-orange);
    }

    .song-item.available {
      border-left-color: var(--available);
    }

    .song-item.resting {
      border-left-color: var(--resting);
    }

    .song-item.played {
      border-left-color: var(--played);
      opacity: 0.6;
    }

    .song-name {
      font-size: 1.1rem;
      font-weight: 600;
    }

    .song-status {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .status-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .status-badge.available {
      background: rgba(74, 222, 128, 0.2);
      color: var(--available);
    }

    .status-badge.resting {
      background: rgba(251, 191, 36, 0.2);
      color: var(--resting);
    }

    .status-badge.played {
      background: rgba(248, 113, 113, 0.2);
      color: var(--played);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .stat-card {
      background: var(--bg-dark);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      text-align: center;
    }

    .stat-value {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2.5rem;
      letter-spacing: 0.05em;
      background: linear-gradient(135deg, var(--accent-red), var(--accent-orange));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .search-box {
      margin-bottom: 1rem;
    }

    .search-box input {
      width: 100%;
      padding: 0.75rem 1rem;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 1rem;
    }

    .empty-state {
      text-align: center;
      padding: 3rem 1rem;
      color: var(--text-muted);
    }

    .empty-state-icon {
      font-size: 4rem;
      margin-bottom: 1rem;
    }

    .help-text {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-top: 0.5rem;
      font-style: italic;
    }

    .setlist-display {
      margin-bottom: 1rem;
      padding: 1rem;
      background: var(--bg-dark);
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .setlist-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .setlist-date {
      font-weight: 600;
      color: var(--accent-orange);
    }

    .setlist-songs {
      font-size: 0.9rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .live-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: rgba(74, 222, 128, 0.1);
      border: 1px solid var(--available);
      border-radius: 20px;
      font-size: 0.85rem;
      color: var(--available);
      animation: pulse-live 2s ease-in-out infinite;
    }

    @keyframes pulse-live {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .live-dot {
      width: 8px;
      height: 8px;
      background: var(--available);
      border-radius: 50%;
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .quick-add {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .quick-add input {
      flex: 1;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // Heavy rotation / favorite songs (from Apple Music top songs)
    const FAVORITES = [
      "Up All Night",
      "Climb To Safety",
      "Ain't Life Grand",
      "Space Wrangler",
      "Airplane",
      "Driving Song",
      "Pleas",
      "Bear's Gone Fishin'",
      "Chilly Water",
      "Tall Boy",
      "Blue Indian",
      "Disco",
      "Party At Your Mama's House",
      "Little Lilly",
      "Nobody's Loss",
      "Porch Song",
      "Little by Little",
      "The Last Straw",
      "Love Tractor",
      "Hatfield",
      "Papa's Home",
      "Wondering",
      "Blackout Blues",
      "Aunt Avis",
      "Hope In A Hopeless World",
      "C. Brown",
      "Pilgrims",
      "And It Stoned Me",
      "Holden Oversoul",
      "Stop-Go",
      "All Time Low",
      "Travelin' Light",
      "Can't Get High",
      "One Arm Steve",
      "Surprise Valley",
      "Walkin' (For Your Love)",
      "Diner",
      "Jack",
      "Dyin' Man",
      "The Waker",
      "Pickin' Up The Pieces"
    ];

    // Songs with city/location references in lyrics
    // Default holiday and theme-based songs (based on lyrics and themes)
    const DEFAULT_THEME_SONGS = {
      // Valentine's Day (Feb 10-18)
      valentine: [
        'Love Tractor',
        'Climb To Safety',
        'Walkin\' (For Your Love)',
        'Mercy',
        'Barstools And Dreamers',
        'Who Do You Belong To',
        'Airplane',
        'Tie Your Shoes',
        'Red Hot Mama',
        'Ride Me High',
        'Genesis',
        'Gradle',
        'Diner',
        'Blight',
        'Space Wrangler',
        'Papa\'s Home',
        'Gimme'
      ],
      
      // July 4th (Jun 30 - Jul 8)
      july4th: ['Disco', 'Ain\'t Life Grand', 'Tall Boy', 'C. Brown', 'Party At Your Mama\'s House', 'North'],
      
      // New Year's (Dec 28 - Jan 5)
      newyear: ['Disco', 'Ain\'t Life Grand', 'Tall Boy', 'C. Brown', 'Party At Your Mama\'s House'],
      
      // City References - Songs with city/location mentions in lyrics
      // Format: "Song:City" - song gets +30 point bonus when predicting for that city
      cityReferences: [
        'Makes Sense To Me:Atlanta',
        'Up All Night:Savannah',
        'Hatfield:San Diego',
        'Hatfield:Los Angeles',
        'Fishwater:New Orleans',
        'Bayou Lena:New Orleans',
        'Hope In A Hopeless World:New York City',
        'Action Man:Saratoga',
        'Bust It Big:New York City'
      ],
      
      // State References - Songs with state mentions
      // Format: "Song:STATE_CODE" - song gets +30 point bonus when predicting for that state
      stateReferences: [
        'Don\'t Tell The Band:GA',
        'Henry Parsons Died:GA',
        'Up All Night:GA',
        'Hatfield:CA',
        'Rebirtha:KS',
        'Visiting Day:TN'
      ],
      
      // Sequential Pairs - Songs that typically follow each other
      // Format: "Song A<->Song B" means they're paired (either order)
      // If one is played, treat the other as if it was also played (both on cooldown)
      sequentialPairs: [
        'Machine<->Barstools And Dreamers',
        'Protein Drink<->Sewing Machine',
        'Goodpeople<->Dark Bar',
        'Travelin\' Man<->The Waker',
        'Jack<->Bear\'s Gone Fishin\'',
        'Bear\'s Gone Fishin\'<->Tie Your Shoes',
        'Party At Your Mama\'s House<->Stop Breakin\' Down Blues',
        'Surprise Valley<->Blackout Blues'
      ]
    };

    // Coastal cities within 30 miles of ocean (for beach theme)
    const BEACH_CITIES = [
      // East Coast
      'miami', 'fort lauderdale', 'west palm beach', 'jacksonville', 'st. augustine',
      'savannah', 'charleston', 'myrtle beach', 'wilmington', 'outer banks',
      'virginia beach', 'norfolk', 'ocean city', 'rehoboth', 'atlantic city',
      'asbury park', 'long beach', 'brooklyn', 'queens', 'boston', 'portland',
      'providence', 'newport', 'cape cod',
      // Gulf Coast
      'tampa', 'st. petersburg', 'clearwater', 'sarasota', 'naples', 'fort myers',
      'pensacola', 'panama city', 'destin', 'mobile', 'gulfport', 'biloxi',
      'new orleans', 'galveston', 'corpus christi', 'south padre',
      // West Coast
      'san diego', 'los angeles', 'santa monica', 'malibu', 'santa barbara',
      'san luis obispo', 'monterey', 'santa cruz', 'san francisco', 'oakland',
      'berkeley', 'sausalito', 'portland', 'seattle', 'tacoma',
      // Hawaii & Alaska
      'honolulu', 'maui', 'kauai', 'anchorage', 'juneau'
    ];

    // Get date-based theme for a specific date
    const getDateTheme = (dateString) => {
      const targetDate = dateString ? new Date(dateString + 'T12:00:00') : new Date();
      const month = targetDate.getMonth() + 1;
      const day = targetDate.getDate();
      
      // Helper to check if date is within +/- 4 days of target
      const isWithinRange = (targetMonth, targetDay) => {
        const target = new Date(targetDate.getFullYear(), targetMonth - 1, targetDay);
        const diff = Math.abs(targetDate - target) / (1000 * 60 * 60 * 24); // days
        return diff <= 4;
      };
      
      // Valentine's Day (Feb 14 +/- 4 days = Feb 10-18)
      if (month === 2 && isWithinRange(2, 14)) return 'valentine';
      
      // July 4th (Jul 4 +/- 4 days = Jun 30 - Jul 8)
      if ((month === 6 && day >= 30) || (month === 7 && day <= 8)) return 'july4th';
      
      // New Year's (Jan 1 +/- 4 days = Dec 28 - Jan 5)
      if ((month === 12 && day >= 28) || (month === 1 && day <= 5)) return 'newyear';
      
      return null;
    };

    // Check if city is a beach location (within 30mi of ocean)
    const isBeachCity = (cityString) => {
      if (!cityString) return false;
      const cityLower = cityString.toLowerCase();
      return BEACH_CITIES.some(beach => cityLower.includes(beach));
    };

    // Complete song database from the lyrics file
    const ALL_SONGS = [
      "Chilly Water", "Travelin' Light", "Space Wrangler", "Coconut", "Porch Song",
      "Stop-Go", "Driving Song", "Holden Oversoul", "Contentment Blues", "Me And The Devil Blues",
      "Heaven", "Send Your Mind", "Walkin' (For Your Love)", "Pigeons", "Mercy", "Rock",
      "Makes Sense To Me", "C. Brown", "Love Tractor", "Weight Of The World", "I'm Not Alone",
      "Barstools And Dreamers", "Proving Ground", "The Last Straw", "Pleas", "Hatfield",
      "Wondering", "Papa's Home", "Diner", "Better Off", "Pickin' Up The Pieces",
      "Henry Parsons Died", "Pilgrims", "Postcard", "Dream Song", "Little Kin", "Ain't Life Grand",
      "Airplane", "Can't Get High", "Heroes", "Raise The Roof", "Junior", "Blackout Blues",
      "Jack", "Fishwater", "Radio Child", "Aunt Avis", "Tall Boy", "Gradle", "Glory",
      "Rebirtha", "You Got Yours", "Hope In A Hopeless World", "Greta", "Surprise Valley",
      "Bear's Gone Fishin'", "Climb To Safety", "Blue Indian", "The Waker", "Dyin' Man",
      "You'll Be Fine", "One Arm Steve", "Christmas Katie", "All Time Low", "Nobody's Loss",
      "Fishing", "Thin Air (Smells Like Mississippi)", "Tortured Artist", "Papa Johnny Road",
      "Sparks Fly", "Counting Train Cars", "Don't Wanna Lose You", "Longer Look",
      "Meeting of the Waters", "Nebulous", "Monstrosity", "Time Waits", "Travelin' Man",
      "Second Skin", "Goodpeople", "From The Cradle", "Solid Rock", "Time Zones",
      "When The Clowns Come Home", "Ribs And Whiskey", "Crazy", "You Should Be Glad",
      "May Your Glass Be Filled", "Boom Boom Boom", "Walk On The Flood", "Angels On High",
      "Three Candles", "Tickle The Truth", "Free Somehow", "Flicker", "Dark Day Program",
      "Her Dance Needs No Body", "Already Fried", "Up All Night", "Saint Ex", "North",
      "Dirty Side Down", "This Cruel Thing", "Visiting Day", "Clinic Cynic", "Shut Up And Drive",
      "True To My Nature", "When You Coming Home", "Jaded Tourist", "Cotton Was King", "Cosmic Confidante"
    ].sort();

    // Common covers and variations (not in official lyrics but played frequently)
    const COMMON_COVERS = [
      "Low Spark Of High Heeled Boys",
      "Bowlegged Woman",
      "Let's Get Down To Business",
      "Sleeping Man",
      "Conrad",
      "Machine",
      "Dark Bar",
      "Party At Your Mama's House",
      "Stop Breakin' Down Blues",
      "Mr. Soul",
      "Little By Little",
      "Walk On",
      "Pleas",
      "There Is A Time",
      "Let's Get The Show On The Road",
      "Sewing Machine",
      "Protein Drink",
      "Bust It Big",
      "We Walk Each Other Home",
      "Don't Be Denied",
      "Down in a Hole",
      "Who Do You Belong To?",
      "Big Wooly Mammoth",
      "King Baby",
      "Sitting In Limbo",
      "I Can See Clearly Now",
      "Paranoid",
      "War Pigs",
      "Disco",
      "Tie Your Shoes",
      "Ride Me High",
      "Little Lilly",
      "Trashy",
      "Lawyers Guns And Money",
      "Down",
      "Drums",
      "Jam",
      "Arleen",
      "Smokestack Lightning",
      "Blight",
      "Pusherman",
      "For What It's Worth",
      "Action Man",
      "Good Morning Little Schoolgirl",
      "Chainsaw City",
      "I Walk On Guilded Splinters",
      "I'm So Glad",
      "And It Stoned Me",
      "Red Hot Mama",
      "Spoonful",
      "Maggot Brain",
      "Jack Straw",
      "Blue Carousel",
      "The Take Out"
    ];

    // Fuzzy match song names to handle variations
    const normalizeSongName = (name) => {
      return name
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, '') // Remove special chars
        .replace(/\s+/g, ' ')
        .trim();
    };

    const findSongMatch = (inputSong) => {
      const normalized = normalizeSongName(inputSong);
      
      // Exact match first
      const exactMatch = ALL_SONGS_WITH_COVERS.find(s => 
        normalizeSongName(s) === normalized
      );
      if (exactMatch) return exactMatch;

      // Partial match (contains)
      const partialMatch = ALL_SONGS_WITH_COVERS.find(s =>
        normalizeSongName(s).includes(normalized) || 
        normalized.includes(normalizeSongName(s))
      );
      if (partialMatch) return partialMatch;

      // Return original if no match (will be marked as unknown)
      return inputSong;
    };

    function PanicSetlistPredictor() {
      const [mode, setMode] = useState('setup'); // setup, live, view
      const [setlists, setSetlists] = useState([]);
      const [currentRun, setCurrentRun] = useState(null);
      const [liveSetlist, setLiveSetlist] = useState([]);
      const [searchTerm, setSearchTerm] = useState('');
      const [sortBy, setSortBy] = useState('showsSince'); // 'alpha', 'showsSince', 'status'
      const [newDate, setNewDate] = useState('');
      const [newSongs, setNewSongs] = useState('');
      const [quickAdd, setQuickAdd] = useState('');
      const [isRun, setIsRun] = useState(false);
      const [runDays, setRunDays] = useState(4);
      const [nextRunCity, setNextRunCity] = useState('austin');
      const [editingSetlist, setEditingSetlist] = useState(null); // ID of setlist being edited
      const [unmatchedSongs, setUnmatchedSongs] = useState([]); // Songs that couldn't be matched
      const [customSongs, setCustomSongs] = useState([]); // User-added songs
      const [selectedSongHistory, setSelectedSongHistory] = useState(null); // {song: string, dates: [{date, city}]}
      const [selectedPredictionDetail, setSelectedPredictionDetail] = useState(null); // {show, predictions, actual}
      const [themeSongs, setThemeSongs] = useState({}); // Theme song lists - loaded from GitHub, edits stored locally
      const [editingTheme, setEditingTheme] = useState(null); // {key: 'valentine', label: 'Valentine's Day', songs: [...]}
      const [themeSearchTerm, setThemeSearchTerm] = useState('');
      const [pairSongA, setPairSongA] = useState('');
      const [pairSongB, setPairSongB] = useState('');
      const [pairSearchA, setPairSearchA] = useState('');
      const [pairSearchB, setPairSearchB] = useState('');
      const [citySong, setCitySong] = useState('');
      const [cityName, setCityName] = useState('');
      const [citySongSearch, setCitySongSearch] = useState('');
      const [stateSong, setStateSong] = useState('');
      const [stateCode, setStateCode] = useState('');
      const [stateSongSearch, setStateSongSearch] = useState('');

      // Combine all available songs (base + covers + custom)
      const ALL_SONGS_WITH_COVERS = useMemo(() => {
        return [...new Set([...ALL_SONGS, ...COMMON_COVERS, ...customSongs])].sort();
      }, [customSongs]);

      // Find song match using fuzzy matching
      const findSongMatch = (inputSong) => {
        const normalized = normalizeSongName(inputSong);
        
        // Exact match first
        const exactMatch = ALL_SONGS_WITH_COVERS.find(s => 
          normalizeSongName(s) === normalized
        );
        if (exactMatch) return exactMatch;

        // Partial match (contains) - but require reasonable length to avoid "Jam" matching "Jamais Vu"
        // Only do substring matching if input is at least 5 chars OR if it's an exact word boundary match
        if (normalized.length >= 5) {
          const partialMatch = ALL_SONGS_WITH_COVERS.find(s =>
            normalizeSongName(s).includes(normalized) || 
            normalized.includes(normalizeSongName(s))
          );
          if (partialMatch) return partialMatch;
        } else {
          // For short inputs (< 5 chars), only match if it's a complete word
          const wordMatch = ALL_SONGS_WITH_COVERS.find(s => {
            const songNormalized = normalizeSongName(s);
            // Split into words and check if input matches any complete word
            const songWords = songNormalized.split(/\s+/);
            return songWords.includes(normalized);
          });
          if (wordMatch) return wordMatch;
        }

        // Return null if no match found
        return null;
      };

      // Load from storage on mount
      useEffect(() => {
        // Load canonical data from GitHub
        const loadFromGitHub = async () => {
          try {
            // Load setlists
            const setlistsResponse = await fetch('https://neilgolson.com/setlists.json');
            // Load theme songs
            const themesResponse = await fetch('https://neilgolson.com/theme-songs.json');
            
            if (setlistsResponse.ok && themesResponse.ok) {
              const setlistsData = await setlistsResponse.json();
              const themesData = await themesResponse.json();
              
              console.log('âœ… Loaded canonical setlists from GitHub:', setlistsData.setlists.length, 'shows');
              console.log('âœ… Loaded canonical themes from GitHub');
              
              setSetlists(setlistsData.setlists || []);
              
              // Extract all unique songs from setlists that aren't in master database
              const allSongsInSetlists = new Set();
              setlistsData.setlists.forEach(setlist => {
                setlist.songs.forEach(song => {
                  allSongsInSetlists.add(song);
                });
              });
              
              // Find songs that aren't in ALL_SONGS or COMMON_COVERS
              const missingSongs = Array.from(allSongsInSetlists).filter(song => 
                !ALL_SONGS.includes(song) && !COMMON_COVERS.includes(song)
              );
              
              console.log('ðŸ“‹ Found', missingSongs.length, 'songs in setlists not in master database');
              
              // Merge canonical themes with user edits from localStorage
              const localPrefs = localStorage.getItem('panicSetlists');
              if (localPrefs) {
                const prefs = JSON.parse(localPrefs);
                
                // Merge missing songs from setlists with user's custom songs
                const userCustomSongs = prefs.customSongs || [];
                const allCustomSongs = [...new Set([...missingSongs, ...userCustomSongs])];
                setCustomSongs(allCustomSongs);
                
                // Merge: Start with GitHub themes, override with user edits
                const mergedThemes = { ...themesData };
                if (prefs.themeEdits) {
                  Object.keys(prefs.themeEdits).forEach(themeKey => {
                    mergedThemes[themeKey] = prefs.themeEdits[themeKey];
                  });
                }
                setThemeSongs(mergedThemes);
              } else {
                // No local prefs, just use songs from setlists and GitHub themes
                setCustomSongs(missingSongs);
                setThemeSongs(themesData);
              }
              
              return true;
            }
          } catch (error) {
            console.warn('Could not load from GitHub, falling back to localStorage:', error);
          }
          return false;
        };
        
        // Try GitHub first, fall back to localStorage
        loadFromGitHub().then(success => {
          if (!success) {
            // Fallback to localStorage if GitHub fails
            const saved = localStorage.getItem('panicSetlists');
            if (saved) {
              const data = JSON.parse(saved);
              setSetlists(data.setlists || []);
              setCustomSongs(data.customSongs || []);
              setThemeSongs(data.themeSongs || DEFAULT_THEME_SONGS);
              console.log('ðŸ“‚ Loaded from localStorage (GitHub unavailable)');
            }
          }
          
          // Auto-detect if run has ended (from whichever source we loaded)
          const saved = localStorage.getItem('panicSetlists');
          if (saved) {
            const data = JSON.parse(saved);
            let loadedRun = data.currentRun || null;
            if (loadedRun && setlists && setlists.length > 0) {
              const sortedShows = [...setlists].sort((a, b) => new Date(b.date) - new Date(a.date));
              const mostRecentShow = sortedShows[0];
              const mostRecentDate = new Date(mostRecentShow.date);
              const today = new Date();
              const daysSince = Math.floor((today - mostRecentDate) / (1000 * 60 * 60 * 24));
              
              if (daysSince > 1) {
                loadedRun = null;
                setIsRun(false);
              }
            }
            setCurrentRun(loadedRun);
          }
        });
      }, []);

      // Save user preferences to localStorage (NOT setlists or themes - those come from GitHub)
      useEffect(() => {
        const existing = JSON.parse(localStorage.getItem('panicSetlists') || '{}');
        localStorage.setItem('panicSetlists', JSON.stringify({
          ...existing, // Preserve themeEdits
          currentRun,
          customSongs
        }));
      }, [currentRun, customSongs]);

      const addSetlist = () => {
        if (!newSongs) return;

        let extractedDate = newDate;
        let extractedCity = currentRun?.city || '';
        let extractedVenue = '';
        let songsText = newSongs;

        // Try to detect Everyday Companion format
        // Format can be:
        // Line 1: MM/DD/YY Venue Name, City, State
        // Line 2: 1: Song1, Song2...
        // OR single line: MM/DD/YY Venue, City, State1: Song1...
        const lines = newSongs.split('\n').map(l => l.trim()).filter(l => l);
        const firstLine = lines[0] || '';
        
        // Check if first line contains a date pattern
        const dateMatch = firstLine.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s+(.+?),\s*([^,]+?)(?:,\s*([A-Z]{2}))?$/);
        
        if (dateMatch) {
          const [fullMatch, month, day, year, venuePart, cityPart, state] = dateMatch;
          
          // Convert date to YYYY-MM-DD format
          const fullYear = year.length === 2 ? `20${year}` : year;
          extractedDate = `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
          
          // Extract venue and city
          if (venuePart) {
            extractedVenue = venuePart.trim();
          }
          
          if (cityPart) {
            extractedCity = cityPart.trim();
            if (state) {
              extractedCity = `${cityPart.trim()}, ${state}`;
            }
          }
          
          // Remove the first line (date/venue/city) from songs text
          songsText = lines.slice(1).join('\n').trim();
          
          // Also try to remove venue/city from the beginning of the songs text if it appears
          // This handles cases where venue/city info bleeds into the song list
          if (extractedVenue && songsText.toLowerCase().startsWith(extractedVenue.toLowerCase())) {
            songsText = songsText.substring(extractedVenue.length).replace(/^[,\s]+/, '');
          }
          if (extractedCity) {
            const cityWithoutState = extractedCity.split(',')[0].trim();
            if (songsText.toLowerCase().startsWith(cityWithoutState.toLowerCase())) {
              songsText = songsText.substring(cityWithoutState.length).replace(/^[,\s]+/, '');
            }
          }
        }

        // If still no date, check if user filled it manually
        if (!extractedDate) {
          alert('Please paste a setlist with a date, or enter the date manually.');
          return;
        }

        // Show confirmation dialog with extracted info
        const confirmMessage = `Confirm setlist details:\n\n` +
          `Date: ${extractedDate}\n` +
          `${extractedVenue ? `Venue: ${extractedVenue}\n` : ''}` +
          `${extractedCity ? `City: ${extractedCity}\n` : ''}` +
          `\nProceed with adding this setlist?`;
        
        if (!confirm(confirmMessage)) {
          return;
        }

        const rawSongs = songsText
          .split(/[,\n>]/)  // Also split on > for segues
          .map(s => s.trim())
          .filter(s => s.length > 0)
          // Remove set markers from beginning of song names (e.g., "1: Song" -> "Song", "E1: Song" -> "Song")
          .map(s => s.replace(/^(1|2|3|E\d?):\s*/, '').trim())
          // Remove trailing set markers from song names (e.g., "Song1:" -> "Song")
          .map(s => s.replace(/\d+:$/, '').trim())
          // Remove asterisks at end
          .map(s => s.replace(/\*+$/, '').trim())
          // Filter out standalone set markers if they somehow remain
          .filter(s => !s.match(/^(1|2|3|E\d?):?$/))
          .filter(s => !['Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          // Remove city/state patterns and venue/date info
          .filter(s => {
            // Skip if it's just a 2-letter state code
            if (s.match(/^[A-Z]{2}$/)) {
              return false;
            }
            
            // Skip if it looks like a date pattern (MM/DD/YY or variations)
            if (s.match(/^\d{1,2}\/\d{1,2}\/\d{2,4}$/)) {
              return false;
            }
            
            // Skip if it's the extracted city (case insensitive, exact match)
            if (extractedCity) {
              const cityLower = extractedCity.toLowerCase().trim();
              const sLower = s.toLowerCase().trim();
              
              // Exact match
              if (sLower === cityLower) {
                return false;
              }
              
              // Check if s is part of the city name (e.g., "Port Chester" vs "Port" or "Chester")
              const cityParts = cityLower.split(/[\s,]+/);
              if (cityParts.includes(sLower)) {
                return false;
              }
              
              // Check if s contains the city or vice versa
              if (cityLower.includes(sLower) || sLower.includes(cityLower)) {
                return false;
              }
            }
            
            // Skip if it's the extracted venue (case insensitive)
            if (extractedVenue) {
              const venueLower = extractedVenue.toLowerCase().trim();
              const sLower = s.toLowerCase().trim();
              
              // Check if s is part of venue name
              if (venueLower.includes(sLower) || sLower.includes(venueLower)) {
                return false;
              }
              
              // Check venue parts
              const venueParts = venueLower.split(/[\s,]+/);
              if (venueParts.includes(sLower)) {
                return false;
              }
            }
            
            return true;
          })
          // Filter out empty strings after all processing
          .filter(s => s.length > 0);

        // Try to match each song
        const matchedSongs = [];
        const unmatched = [];
        const newCustomSongs = []; // Track new songs to add
        
        rawSongs.forEach(rawSong => {
          const matched = findSongMatch(rawSong);
          if (matched) {
            matchedSongs.push(matched);
            // If this matched song is not in the master database, add it to custom songs
            if (!ALL_SONGS.includes(matched) && !COMMON_COVERS.includes(matched)) {
              newCustomSongs.push(matched);
            }
          } else {
            unmatched.push(rawSong);
          }
        });
        
        // Add any new songs to customSongs
        if (newCustomSongs.length > 0) {
          setCustomSongs(prev => {
            const allCustom = [...prev, ...newCustomSongs];
            // Remove duplicates
            return [...new Set(allCustom)];
          });
        }

        // If there are unmatched songs, show them to the user
        if (unmatched.length > 0) {
          setUnmatchedSongs(unmatched);
          // Store extracted data for later use
          setNewDate(extractedDate);
          if (extractedCity) {
            setCurrentRun({ days: runDays, city: extractedCity });
            setIsRun(true);
          }
          // Don't add the setlist yet - wait for user to review unmatched songs
          return;
        }

        // Create and add the setlist
        const newSetlist = {
          date: extractedDate,
          songs: matchedSongs,
          city: extractedCity,
          venue: extractedVenue,
          id: Date.now()
        };

        // Add and sort by date (newest first)
        setSetlists(prev => {
          const updated = [newSetlist, ...prev];
          const sorted = updated.sort((a, b) => new Date(b.date) - new Date(a.date));
          
          // Auto-detect runs: check if consecutive shows have the same city
          if (sorted.length >= 2 && newSetlist.city) {
            let consecutiveSameCity = 1;
            for (let i = 1; i < sorted.length; i++) {
              if (sorted[i].city && sorted[i].city.toLowerCase() === newSetlist.city.toLowerCase()) {
                consecutiveSameCity++;
              } else {
                break;
              }
            }
            
            // If 2+ consecutive shows in same city, enable run mode
            if (consecutiveSameCity >= 2) {
              setCurrentRun({ days: consecutiveSameCity, city: newSetlist.city });
              setIsRun(true);
              setRunDays(consecutiveSameCity);
            }
          }
          
          return sorted;
        });
        setNewDate('');
        setNewSongs('');
      };

      const addUnmatchedSongsAndContinue = () => {
        // Add unmatched songs to custom songs list
        setCustomSongs(prev => [...prev, ...unmatchedSongs]);
        
        // Now process the setlist with all songs (including newly added ones)
        const allSongs = newSongs
          .split(/[,\n>]/)
          .map(s => s.trim())
          .filter(s => s.length > 0)
          .filter(s => !['1:', '2:', '3:', 'E:', 'Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          .map(s => s.replace(/\*+$/, '').trim())
          .map(rawSong => {
            // Try to match in updated list
            const allAvailable = [...ALL_SONGS, ...COMMON_COVERS, ...customSongs, ...unmatchedSongs];
            return allAvailable.find(song => 
              normalizeSongName(song) === normalizeSongName(rawSong) ||
              normalizeSongName(song).includes(normalizeSongName(rawSong)) ||
              normalizeSongName(rawSong).includes(normalizeSongName(song))
            ) || rawSong; // Use raw name if still no match
          });

        const newSetlist = {
          date: newDate,
          songs: allSongs,
          city: currentRun?.city || '',
          id: Date.now()
        };

        setSetlists(prev => {
          const updated = [newSetlist, ...prev];
          const sorted = updated.sort((a, b) => new Date(b.date) - new Date(a.date));
          
          if (sorted.length >= 2 && newSetlist.city) {
            let consecutiveSameCity = 1;
            for (let i = 1; i < sorted.length; i++) {
              if (sorted[i].city && sorted[i].city.toLowerCase() === newSetlist.city.toLowerCase()) {
                consecutiveSameCity++;
              } else {
                break;
              }
            }
            
            if (consecutiveSameCity >= 2) {
              setCurrentRun({ days: consecutiveSameCity, city: newSetlist.city });
              setIsRun(true);
              setRunDays(consecutiveSameCity);
            }
          }
          
          return sorted;
        });

        setUnmatchedSongs([]);
        setNewDate('');
        setNewSongs('');
      };

      const skipUnmatchedAndContinue = () => {
        // Process setlist without unmatched songs
        const matchedSongs = newSongs
          .split(/[,\n>]/)
          .map(s => s.trim())
          .filter(s => s.length > 0)
          .filter(s => !['1:', '2:', '3:', 'E:', 'Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          .map(s => s.replace(/\*+$/, '').trim())
          .map(findSongMatch)
          .filter(s => s); // Remove nulls
        
        // Auto-add any matched songs that aren't in master database to customSongs
        const newCustomSongs = matchedSongs.filter(song => 
          !ALL_SONGS.includes(song) && !COMMON_COVERS.includes(song)
        );
        
        if (newCustomSongs.length > 0) {
          setCustomSongs(prev => {
            const allCustom = [...prev, ...newCustomSongs];
            return [...new Set(allCustom)]; // Remove duplicates
          });
        }

        const newSetlist = {
          date: newDate,
          songs: matchedSongs,
          city: currentRun?.city || '',
          id: Date.now()
        };

        setSetlists(prev => {
          const updated = [newSetlist, ...prev];
          const sorted = updated.sort((a, b) => new Date(b.date) - new Date(a.date));
          
          if (sorted.length >= 2 && newSetlist.city) {
            let consecutiveSameCity = 1;
            for (let i = 1; i < sorted.length; i++) {
              if (sorted[i].city && sorted[i].city.toLowerCase() === newSetlist.city.toLowerCase()) {
                consecutiveSameCity++;
              } else {
                break;
              }
            }
            
            if (consecutiveSameCity >= 2) {
              setCurrentRun({ days: consecutiveSameCity, city: newSetlist.city });
              setIsRun(true);
              setRunDays(consecutiveSameCity);
            }
          }
          
          return sorted;
        });

        setUnmatchedSongs([]);
        setNewDate('');
        setNewSongs('');
      };

      const deleteSetlist = (id) => {
        setSetlists(prev => prev.filter(s => s.id !== id));
      };

      const showSongHistory = (songName) => {
        // Find all shows where this song was played
        const playedShows = setlists
          .filter(setlist => setlist.songs.includes(songName))
          .map(setlist => ({
            date: setlist.date,
            city: setlist.city || '',
            songs: setlist.songs // Include for debugging
          }))
          .sort((a, b) => new Date(b.date) - new Date(a.date)); // Most recent first

        console.log(`Song history for "${songName}":`, playedShows);
        console.log('All setlists:', setlists);
        
        setSelectedSongHistory({
          song: songName,
          dates: playedShows
        });
      };

      const startEditingTheme = (themeKey, themeLabel) => {
        setEditingTheme({
          key: themeKey,
          label: themeLabel,
          songs: [...themeSongs[themeKey]]
        });
        setThemeSearchTerm('');
        setPairSongA('');
        setPairSongB('');
        setPairSearchA('');
        setPairSearchB('');
      };

      const addPairToTheme = () => {
        if (editingTheme && pairSongA && pairSongB) {
          const pairString = `${pairSongA}<->${pairSongB}`;
          if (!editingTheme.songs.includes(pairString)) {
            setEditingTheme({
              ...editingTheme,
              songs: [...editingTheme.songs, pairString]
            });
          }
          setPairSongA('');
          setPairSongB('');
          setPairSearchA('');
          setPairSearchB('');
        }
      };

      const addCityRefToTheme = () => {
        if (editingTheme && citySong && cityName) {
          const cityRefString = `${citySong}:${cityName}`;
          if (!editingTheme.songs.includes(cityRefString)) {
            setEditingTheme({
              ...editingTheme,
              songs: [...editingTheme.songs, cityRefString]
            });
          }
          setCitySong('');
          setCityName('');
          setCitySongSearch('');
        }
      };

      const addStateRefToTheme = () => {
        if (editingTheme && stateSong && stateCode) {
          const stateRefString = `${stateSong}:${stateCode}`;
          if (!editingTheme.songs.includes(stateRefString)) {
            setEditingTheme({
              ...editingTheme,
              songs: [...editingTheme.songs, stateRefString]
            });
          }
          setStateSong('');
          setStateCode('');
          setStateSongSearch('');
        }
      };

      const addSongToTheme = (song) => {
        if (editingTheme && !editingTheme.songs.includes(song)) {
          setEditingTheme({
            ...editingTheme,
            songs: [...editingTheme.songs, song]
          });
        }
      };

      const removeSongFromTheme = (song) => {
        if (editingTheme) {
          setEditingTheme({
            ...editingTheme,
            songs: editingTheme.songs.filter(s => s !== song)
          });
        }
      };

      const saveThemeEdits = () => {
        if (editingTheme) {
          const updatedThemes = {
            ...themeSongs,
            [editingTheme.key]: editingTheme.songs
          };
          setThemeSongs(updatedThemes);
          
          // Save to localStorage - store as themeEdits (only the differences from GitHub)
          const localPrefs = JSON.parse(localStorage.getItem('panicSetlists') || '{}');
          localPrefs.themeEdits = localPrefs.themeEdits || {};
          localPrefs.themeEdits[editingTheme.key] = editingTheme.songs;
          localStorage.setItem('panicSetlists', JSON.stringify(localPrefs));
          
          setEditingTheme(null);
        }
      };

      const cancelThemeEdit = () => {
        setEditingTheme(null);
        setThemeSearchTerm('');
      };

      const startEditingSetlist = (setlist) => {
        setEditingSetlist(setlist.id);
        setNewDate(setlist.date);
        setNewSongs(setlist.songs.join(', '));
        if (setlist.city) {
          setCurrentRun({ days: runDays, city: setlist.city });
          setIsRun(true);
        }
      };

      const saveEditedSetlist = () => {
        if (!editingSetlist || !newDate || !newSongs) return;

        const songs = newSongs
          .split(/[,\n>]/)
          .map(s => s.trim())
          .filter(s => s.length > 0)
          .filter(s => !['1:', '2:', '3:', 'E:', 'Set', 'Set 1', 'Set 2', 'Set 3', 'Encore'].includes(s))
          .map(s => s.replace(/\*+$/, '').trim())
          .map(findSongMatch)
          .filter(s => s); // Remove nulls
        
        // Auto-add any matched songs that aren't in master database to customSongs
        const newCustomSongs = songs.filter(song => 
          !ALL_SONGS.includes(song) && !COMMON_COVERS.includes(song)
        );
        
        if (newCustomSongs.length > 0) {
          setCustomSongs(prev => {
            const allCustom = [...prev, ...newCustomSongs];
            return [...new Set(allCustom)]; // Remove duplicates
          });
        }

        setSetlists(prev => {
          const updated = prev.map(s => {
            if (s.id === editingSetlist) {
              return {
                ...s,
                date: newDate,
                songs: songs,
                city: currentRun?.city || ''
              };
            }
            return s;
          });
          return updated.sort((a, b) => new Date(b.date) - new Date(a.date));
        });

        // Clear edit mode
        setEditingSetlist(null);
        setNewDate('');
        setNewSongs('');
        setIsRun(false);
        setCurrentRun(null);
      };

      const cancelEdit = () => {
        setEditingSetlist(null);
        setNewDate('');
        setNewSongs('');
        setIsRun(false);
        setCurrentRun(null);
      };

      const startLiveMode = () => {
        setMode('live');
        setLiveSetlist([]);
      };

      const addSongToLive = (song) => {
        if (!liveSetlist.includes(song)) {
          setLiveSetlist(prev => [...prev, song]);
        }
        setQuickAdd('');
      };

      const removeSongFromLive = (song) => {
        setLiveSetlist(prev => prev.filter(s => s !== song));
      };

      const saveLiveSetlist = () => {
        if (liveSetlist.length === 0) return;
        
        const today = new Date().toISOString().split('T')[0];
        const newSetlist = {
          date: today,
          songs: liveSetlist,
          id: Date.now()
        };

        setSetlists(prev => [newSetlist, ...prev].slice(0, 10));
        setLiveSetlist([]);
        setMode('view');
      };

      // Calculate song availability based on 3-show rule
      const songStatus = useMemo(() => {
        const status = {};
        
        // Initialize all songs as available
        ALL_SONGS_WITH_COVERS.forEach(song => {
          status[song] = {
            available: true,
            lastPlayed: null,
            showsSince: Infinity,
            inCurrentRun: false,
            timesPlayed: 0,
            playFrequency: 0
          };
        });

        // Sort setlists by date (newest first) for consistent processing
        const sortedSetlists = [...setlists].sort((a, b) => new Date(b.date) - new Date(a.date));

        // Count total plays for each song (deduplicate within each setlist)
        sortedSetlists.forEach(setlist => {
          const uniqueSongs = [...new Set(setlist.songs)];
          uniqueSongs.forEach(song => {
            if (status[song]) {
              status[song].timesPlayed++;
            }
          });
        });

        // Calculate play frequency
        const totalShows = sortedSetlists.length;
        if (totalShows > 0) {
          ALL_SONGS_WITH_COVERS.forEach(song => {
            if (status[song]) {
              status[song].playFrequency = (status[song].timesPlayed / totalShows) * 100;
            }
          });
        }

        // Apply 3-show rule - process all shows to find when each song was last played
        sortedSetlists.forEach((setlist, index) => {
          setlist.songs.forEach(song => {
            if (status[song]) {
              // Only set the FIRST time we see this song (most recent since sorted newest first)
              if (status[song].showsSince === Infinity) {
                status[song].showsSince = index;
                status[song].lastPlayed = setlist.date;
                status[song].available = (index >= 3);
              }
            }
          });
        });

        // Factor in live setlist - only in live mode
        if (mode === 'live' && liveSetlist.length > 0) {
          liveSetlist.forEach(song => {
            if (status[song]) {
              status[song].available = false;
              status[song].lastPlayed = 'Tonight';
              status[song].showsSince = 0;
            }
          });
        }

        // Apply sequential pairing rules - if one song in a pair was played recently, 
        // treat its partner as if it was also played (both on cooldown together)
        const pairs = themeSongs['sequentialPairs'] || [];
        const lastThreeShows = sortedSetlists.slice(0, 3); // Most recent 3 shows
        const recentlyPlayedSongs = new Set();
        lastThreeShows.forEach(setlist => {
          setlist.songs.forEach(song => recentlyPlayedSongs.add(song));
        });
        
        // Parse pairs and apply cooldown
        pairs.forEach(pairString => {
          if (pairString.includes('<->')) {
            const [songA, songB] = pairString.split('<->').map(s => s.trim());
            
            // If Song A was played recently, treat Song B as if it was also played
            if (recentlyPlayedSongs.has(songA) && status[songB]) {
              const songAStatus = status[songA];
              if (songAStatus && songAStatus.showsSince !== Infinity) {
                // Copy the showsSince from the played song to its partner
                status[songB].showsSince = Math.min(status[songB].showsSince, songAStatus.showsSince);
                status[songB].available = (status[songB].showsSince >= 3);
                status[songB].lastPlayed = songAStatus.lastPlayed;
              }
            }
            
            // If Song B was played recently, treat Song A as if it was also played
            if (recentlyPlayedSongs.has(songB) && status[songA]) {
              const songBStatus = status[songB];
              if (songBStatus && songBStatus.showsSince !== Infinity) {
                status[songA].showsSince = Math.min(status[songA].showsSince, songBStatus.showsSince);
                status[songA].available = (status[songA].showsSince >= 3);
                status[songA].lastPlayed = songBStatus.lastPlayed;
              }
            }
          }
        });

        return status;
      }, [setlists, mode, liveSetlist, themeSongs]);

      // Calculate top 20 most frequently played songs from the database (must be after songStatus)
      const heavyRotation = useMemo(() => {
        // Recalculate play counts fresh from setlists
        const playCounts = {};
        
        setlists.forEach(setlist => {
          // Deduplicate songs in each setlist to prevent counting duplicates
          const uniqueSongs = [...new Set(setlist.songs)];
          uniqueSongs.forEach(song => {
            // Exclude instrumental segments
            if (song === 'Drums' || song === 'Jam') return;
            playCounts[song] = (playCounts[song] || 0) + 1;
          });
        });
        
        // Convert to array and sort by play count (descending - most played first)
        const sortedSongs = Object.entries(playCounts)
          .filter(([song, count]) => count >= 3) // Minimum 3 plays for Heavy Rotation
          .sort((a, b) => {
            const countA = a[1];
            const countB = b[1];
            
            // Sort by play count descending (most played at top)
            if (countB > countA) return 1;  // b has more plays, so b comes first
            if (countB < countA) return -1; // a has more plays, so a comes first
            
            // If tie, alphabetical
            return a[0].localeCompare(b[0]);
          })
          .slice(0, 20) // Top 20
          .map(([song]) => song);
        
        return sortedSongs;
      }, [setlists]);

      const filteredSongs = useMemo(() => {
        let songs = ALL_SONGS_WITH_COVERS.filter(song => 
          song.toLowerCase().includes(searchTerm.toLowerCase())
        );

        // Sort based on selected option
        if (sortBy === 'likelihood') {
          // Calculate prediction score for each song using the full algorithm
          songs.sort((a, b) => {
            const aStatus = songStatus[a];
            const bStatus = songStatus[b];
            
            // Calculate score for song A
            let aScore = 0;
            aScore += aStatus.playFrequency * 0.5; // Play frequency (0-50)
            if (heavyRotation.includes(a)) aScore += 30; // Heavy rotation (30)
            if (aStatus.showsSince !== Infinity) aScore += Math.min(15, aStatus.showsSince * 2.5); // Time since (0-15)
            
            // Calculate score for song B
            let bScore = 0;
            bScore += bStatus.playFrequency * 0.5;
            if (heavyRotation.includes(b)) bScore += 30;
            if (bStatus.showsSince !== Infinity) bScore += Math.min(15, bStatus.showsSince * 2.5);
            
            // Sort by score descending (highest first)
            if (bScore !== aScore) {
              return bScore - aScore;
            }
            // Tie: alphabetical
            return a.localeCompare(b);
          });
        } else if (sortBy === 'showsSince') {
          songs.sort((a, b) => {
            const aStatus = songStatus[a];
            const bStatus = songStatus[b];
            
            // Tier 1: Songs played 3+ times
            const aTier1 = aStatus.timesPlayed >= 3;
            const bTier1 = bStatus.timesPlayed >= 3;
            
            // Tier 2: Songs played exactly 3 times
            const aTier2 = aStatus.timesPlayed === 3;
            const bTier2 = bStatus.timesPlayed === 3;
            
            // Tier 3: Songs played exactly 2 times
            const aTier3 = aStatus.timesPlayed === 2;
            const bTier3 = bStatus.timesPlayed === 2;
            
            // Tier 4: Songs played exactly 1 time
            const aTier4 = aStatus.timesPlayed === 1;
            const bTier4 = bStatus.timesPlayed === 1;
            
            // Priority 1: Songs played 3+ times
            if (aTier1 && !bTier1) return -1;
            if (!aTier1 && bTier1) return 1;
            if (aTier1 && bTier1) {
              // Within Tier 1, sort by availability status first
              const aPlayedAndAvailable = aStatus.lastPlayed && aStatus.showsSince > 2;
              const bPlayedAndAvailable = bStatus.lastPlayed && bStatus.showsSince > 2;
              const aResting = aStatus.showsSince >= 0 && aStatus.showsSince <= 2;
              const bResting = bStatus.showsSince >= 0 && bStatus.showsSince <= 2;
              
              // Available songs first
              if (aPlayedAndAvailable && !bPlayedAndAvailable) return -1;
              if (!aPlayedAndAvailable && bPlayedAndAvailable) return 1;
              if (aPlayedAndAvailable && bPlayedAndAvailable) {
                // Among available, sort by longest time since played
                if (bStatus.showsSince !== aStatus.showsSince) {
                  return bStatus.showsSince - aStatus.showsSince;
                }
                return a.localeCompare(b);
              }
              
              // Then resting songs
              if (aResting && !bResting) return -1;
              if (!aResting && bResting) return 1;
              if (aResting && bResting) {
                if (bStatus.showsSince !== aStatus.showsSince) {
                  return bStatus.showsSince - aStatus.showsSince;
                }
                return a.localeCompare(b);
              }
              
              return a.localeCompare(b);
            }
            
            // Priority 2: Songs played exactly 3 times
            if (aTier2 && !bTier2) return -1;
            if (!aTier2 && bTier2) return 1;
            if (aTier2 && bTier2) {
              return a.localeCompare(b);
            }
            
            // Priority 3: Songs played exactly 2 times
            if (aTier3 && !bTier3) return -1;
            if (!aTier3 && bTier3) return 1;
            if (aTier3 && bTier3) {
              return a.localeCompare(b);
            }
            
            // Priority 4: Songs played exactly 1 time
            if (aTier4 && !bTier4) return -1;
            if (!aTier4 && bTier4) return 1;
            if (aTier4 && bTier4) {
              return a.localeCompare(b);
            }
            
            // Never played - alphabetical
            return a.localeCompare(b);
          });
        } else if (sortBy === 'status') {
          songs.sort((a, b) => {
            const aStatus = songStatus[a];
            const bStatus = songStatus[b];
            
            // Available first, then resting, then played
            if (aStatus.available && !bStatus.available) return -1;
            if (!aStatus.available && bStatus.available) return 1;
            if (!aStatus.available && !bStatus.available) {
              if (aStatus.showsSince !== bStatus.showsSince) {
                return bStatus.showsSince - aStatus.showsSince;
              }
            }
            return a.localeCompare(b);
          });
        } else if (sortBy === 'timesPlayed') {
          songs.sort((a, b) => {
            const aStatus = songStatus[a];
            const bStatus = songStatus[b];
            
            // Sort by times played descending (most played first)
            if (bStatus.timesPlayed !== aStatus.timesPlayed) {
              return bStatus.timesPlayed - aStatus.timesPlayed;
            }
            // If tie, alphabetical
            return a.localeCompare(b);
          });
        } else {
          // Alphabetical
          songs.sort();
        }

        return songs;
      }, [searchTerm, sortBy, songStatus]);

      const stats = useMemo(() => {
        const available = Object.values(songStatus).filter(s => s.available).length;
        const resting = Object.values(songStatus).filter(s => !s.available && s.showsSince > 0).length;
        const played = Object.values(songStatus).filter(s => s.showsSince === 0).length;
        
        return { available, resting, played, total: ALL_SONGS_WITH_COVERS.length };
      }, [songStatus]);

      // Calculate accuracy for each show with 20+ shows of history
      const showAccuracy = useMemo(() => {
        const sortedSetlists = [...setlists].sort((a, b) => new Date(a.date) - new Date(b.date));
        const accuracyMap = {};
        
        sortedSetlists.forEach((targetSetlist, targetIndex) => {
          // Need at least 20 shows of history
          if (targetIndex < 20) {
            accuracyMap[targetSetlist.id] = null;
            return;
          }
          
          // Get history (all shows before this one)
          const historySetlists = sortedSetlists.slice(0, targetIndex);
          
          // Detect if target show is part of a run
          // A run is consecutive dates in the same city (within 2 days of each other)
          const targetDate = new Date(targetSetlist.date);
          const targetCity = (targetSetlist.city || '').toLowerCase().trim();
          
          const runShows = [];
          if (targetCity) {
            // Look backwards for consecutive shows in same city
            for (let i = targetIndex - 1; i >= 0; i--) {
              const prevShow = sortedSetlists[i];
              const prevDate = new Date(prevShow.date);
              const prevCity = (prevShow.city || '').toLowerCase().trim();
              const daysDiff = (targetDate - prevDate) / (1000 * 60 * 60 * 24);
              
              // If same city and within 2 days, it's part of the run
              if (prevCity === targetCity && daysDiff <= 2) {
                runShows.unshift(prevShow); // Add to beginning
              } else if (runShows.length > 0) {
                // Found a gap, stop looking
                break;
              }
            }
          }
          
          // Collect songs already played in this run
          const songsPlayedInRun = new Set();
          runShows.forEach(show => {
            const uniqueSongs = [...new Set(show.songs)];
            uniqueSongs.forEach(song => songsPlayedInRun.add(song));
          });
          
          // Build songStatus from history
          const historySongStatus = {};
          ALL_SONGS_WITH_COVERS.forEach(song => {
            historySongStatus[song] = {
              available: true,
              lastPlayed: null,
              showsSince: Infinity,
              timesPlayed: 0,
              playFrequency: 0,
              playedInRun: songsPlayedInRun.has(song) // Track if played in current run
            };
          });
          
          // Count plays
          historySetlists.forEach(setlist => {
            const uniqueSongs = [...new Set(setlist.songs)];
            uniqueSongs.forEach(song => {
              if (historySongStatus[song]) {
                historySongStatus[song].timesPlayed++;
              }
            });
          });
          
          // Calculate frequency
          const totalHistoryShows = historySetlists.length;
          ALL_SONGS_WITH_COVERS.forEach(song => {
            if (historySongStatus[song]) {
              historySongStatus[song].playFrequency = 
                (historySongStatus[song].timesPlayed / totalHistoryShows) * 100;
            }
          });
          
          // Apply 3-show rule - calculate shows since last played
          // We need to iterate FORWARD through history to track when each song was last played
          historySetlists.forEach((setlist, index) => {
            const uniqueSongs = [...new Set(setlist.songs)];
            uniqueSongs.forEach(song => {
              if (historySongStatus[song]) {
                // Mark this song as played at this index
                historySongStatus[song].lastPlayedIndex = index;
                historySongStatus[song].lastPlayed = setlist.date;
              }
            });
          });
          
          // Now calculate showsSince for each song from the perspective of AFTER all history
          const totalShows = historySetlists.length;
          ALL_SONGS_WITH_COVERS.forEach(song => {
            if (historySongStatus[song]) {
              if (historySongStatus[song].lastPlayedIndex !== undefined) {
                // Shows since = total shows - last played index - 1
                historySongStatus[song].showsSince = totalShows - historySongStatus[song].lastPlayedIndex - 1;
                historySongStatus[song].available = historySongStatus[song].showsSince >= 3;
              } else {
                // Never played in history
                historySongStatus[song].showsSince = Infinity;
                historySongStatus[song].available = true;
              }
            }
          });
          
          // Apply sequential pairing rules - if one song in a pair was played recently in history,
          // treat its partner as if it was also played (both on cooldown together)
          const pairs = themeSongs['sequentialPairs'] || [];
          const lastThreeHistory = historySetlists.slice(-3); // Last 3 shows in history
          const recentlyPlayedInHistory = new Set();
          lastThreeHistory.forEach(setlist => {
            setlist.songs.forEach(song => recentlyPlayedInHistory.add(song));
          });
          
          pairs.forEach(pairString => {
            if (pairString.includes('<->')) {
              const [songA, songB] = pairString.split('<->').map(s => s.trim());
              
              // If Song A was played recently, treat Song B as if it was also played
              if (recentlyPlayedInHistory.has(songA) && historySongStatus[songB]) {
                const songAStatus = historySongStatus[songA];
                if (songAStatus && songAStatus.showsSince !== Infinity) {
                  historySongStatus[songB].showsSince = Math.min(
                    historySongStatus[songB].showsSince, 
                    songAStatus.showsSince
                  );
                  historySongStatus[songB].available = (historySongStatus[songB].showsSince >= 3);
                }
              }
              
              // If Song B was played recently, treat Song A as if it was also played
              if (recentlyPlayedInHistory.has(songB) && historySongStatus[songA]) {
                const songBStatus = historySongStatus[songB];
                if (songBStatus && songBStatus.showsSince !== Infinity) {
                  historySongStatus[songA].showsSince = Math.min(
                    historySongStatus[songA].showsSince, 
                    songBStatus.showsSince
                  );
                  historySongStatus[songA].available = (historySongStatus[songA].showsSince >= 3);
                }
              }
            }
          });
          
          // Calculate Heavy Rotation (exclude Drums and Jam)
          const historyHeavyRotation = Object.entries(historySongStatus)
            .filter(([song, status]) => {
              if (song === 'Drums' || song === 'Jam') return false;
              return status.timesPlayed >= 3;
            })
            .sort((a, b) => b[1].timesPlayed - a[1].timesPlayed || a[0].localeCompare(b[0]))
            .slice(0, 20)
            .map(([song]) => song);
          
          // Run prediction algorithm
          const predictions = Object.entries(historySongStatus)
            .filter(([song, status]) => {
              if (song === 'Drums' || song === 'Jam') return false;
              if (status.timesPlayed < 2) return false;
              if (status.playedInRun) return false; // Exclude songs already played in this run
              return status.available || status.showsSince === 2;
            })
            .map(([song, status]) => {
              let score = 0;
              score += status.playFrequency * 0.5;
              if (historyHeavyRotation.includes(song)) score += 30;
              if (status.showsSince !== Infinity) score += Math.min(15, status.showsSince * 2.5);
              
              const cityMatches = historySetlists.some(s => 
                s.city && targetSetlist.city && 
                s.city.toLowerCase() === targetSetlist.city.toLowerCase() && 
                s.songs.includes(song)
              );
              if (cityMatches) score += 30;
              
              const theme = getDateTheme(targetSetlist.date);
              let themeList = theme ? (themeSongs[theme] || []) : [];
              if (isBeachCity(targetSetlist.city)) {
                themeList = [...themeList, ...(themeSongs['beach'] || [])];
              }
              if (themeList.includes(song)) score += 30;
              
              return { song, score };
            })
            .sort((a, b) => b.score - a.score)
            .slice(0, 10)
            .map(p => p.song);
          
          // Check accuracy
          const actualSongs = [...new Set(targetSetlist.songs)];
          const matches = actualSongs.filter(song => predictions.includes(song));
          
          accuracyMap[targetSetlist.id] = {
            matches: matches.length,
            totalPredicted: 10,
            totalPlayed: actualSongs.length,
            predictionAccuracy: ((matches.length / 10) * 100).toFixed(0), // How many of our top 10 were correct
            coverage: ((matches.length / actualSongs.length) * 100).toFixed(0), // What % of their setlist we predicted
            predictions: predictions, // Store the actual predictions
            actualSongs: actualSongs, // Store the actual songs played
            matchedSongs: matches, // Store which songs matched
            runShows: runShows, // Store run information
            songsPlayedInRun: Array.from(songsPlayedInRun) // Songs excluded due to run
          };
        });
        
        return accuracyMap;
      }, [setlists, themeSongs, ALL_SONGS_WITH_COVERS]);

      return (
        <div className="container">
          {/* Unmatched Songs Modal */}
          {unmatchedSongs.length > 0 && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.8)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '2rem'
            }}>
              <div style={{
                background: 'var(--bg-card)',
                border: '2px solid var(--accent-orange)',
                borderRadius: '12px',
                padding: '2rem',
                maxWidth: '600px',
                width: '100%',
                maxHeight: '80vh',
                overflow: 'auto'
              }}>
                <h2 style={{ color: 'var(--accent-orange)', marginBottom: '1rem' }}>
                  âš ï¸ Unmatched Songs Found
                </h2>
                <p style={{ marginBottom: '1rem', color: 'var(--text-secondary)' }}>
                  The following songs couldn't be matched to the database. They might be:
                </p>
                <ul style={{ marginBottom: '1rem', color: 'var(--text-secondary)', paddingLeft: '1.5rem' }}>
                  <li>New covers or originals not in the database</li>
                  <li>Typos or misspellings</li>
                  <li>Song name variations</li>
                </ul>
                
                <div style={{
                  background: 'var(--bg-dark)',
                  padding: '1rem',
                  borderRadius: '6px',
                  marginBottom: '1.5rem',
                  maxHeight: '300px',
                  overflow: 'auto'
                }}>
                  {unmatchedSongs.map((song, i) => (
                    <div key={i} style={{
                      padding: '0.5rem',
                      borderBottom: i < unmatchedSongs.length - 1 ? '1px solid var(--border)' : 'none',
                      color: 'var(--text-primary)'
                    }}>
                      â€¢ {song}
                    </div>
                  ))}
                </div>

                <p style={{ marginBottom: '1.5rem', fontSize: '0.9rem', color: 'var(--text-muted)' }}>
                  What would you like to do?
                </p>

                <div style={{ display: 'flex', gap: '0.5rem', flexDirection: 'column' }}>
                  <button 
                    className="btn btn-primary"
                    onClick={addUnmatchedSongsAndContinue}
                    style={{ width: '100%' }}
                  >
                    âœ“ Add These Songs to Database
                  </button>
                  <button 
                    className="btn btn-secondary"
                    onClick={skipUnmatchedAndContinue}
                    style={{ width: '100%' }}
                  >
                    Skip These Songs
                  </button>
                  <button 
                    className="btn btn-secondary"
                    onClick={() => setUnmatchedSongs([])}
                    style={{ width: '100%' }}
                  >
                    Cancel (Go Back and Fix)
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Song History Modal */}
          {selectedSongHistory && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.8)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '2rem'
            }}>
              <div style={{
                background: 'var(--bg-card)',
                border: '2px solid var(--accent-yellow)',
                borderRadius: '12px',
                padding: '2rem',
                maxWidth: '600px',
                width: '100%',
                maxHeight: '80vh',
                overflow: 'auto'
              }}>
                <h2 style={{ color: 'var(--accent-yellow)', marginBottom: '0.5rem' }}>
                  {selectedSongHistory.song}
                </h2>
                
                {/* Show city reference if available */}
                {(() => {
                  const cityRefs = themeSongs['cityReferences'] || [];
                  const stateRefs = themeSongs['stateReferences'] || [];
                  
                  const songCityRefs = cityRefs
                    .filter(ref => ref.split(':')[0].trim() === selectedSongHistory.song)
                    .map(ref => ref.split(':')[1].trim());
                  
                  const songStateRefs = stateRefs
                    .filter(ref => ref.split(':')[0].trim() === selectedSongHistory.song)
                    .map(ref => ref.split(':')[1].trim());
                  
                  if (songCityRefs.length > 0 || songStateRefs.length > 0) {
                    return (
                      <div style={{
                        padding: '0.75rem',
                        background: 'rgba(255, 140, 66, 0.1)',
                        border: '1px solid var(--accent-orange)',
                        borderRadius: '6px',
                        marginBottom: '1rem'
                      }}>
                        <div style={{ 
                          fontSize: '0.75rem', 
                          color: 'var(--accent-orange)',
                          fontWeight: '600',
                          marginBottom: '0.25rem',
                          textTransform: 'uppercase',
                          letterSpacing: '0.05em'
                        }}>
                          ðŸ“ City/State Reference
                        </div>
                        <div style={{ 
                          fontSize: '0.85rem', 
                          color: 'var(--text-primary)'
                        }}>
                          Gets +30 point bonus in:
                          {songCityRefs.length > 0 && (
                            <div style={{ marginTop: '0.25rem' }}>
                              <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Cities: </span>
                              {songCityRefs.join(', ')}
                            </div>
                          )}
                          {songStateRefs.length > 0 && (
                            <div style={{ marginTop: '0.25rem' }}>
                              <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>States: </span>
                              {songStateRefs.join(', ')}
                            </div>
                          )}
                        </div>
                      </div>
                    );
                  }
                  return null;
                })()}
                
                <div style={{ 
                  fontSize: '0.9rem', 
                  color: 'var(--text-secondary)',
                  marginBottom: '1.5rem'
                }}>
                  Played {selectedSongHistory.dates.length} time{selectedSongHistory.dates.length !== 1 ? 's' : ''}
                </div>
                
                <div style={{
                  background: 'var(--bg-dark)',
                  padding: '1rem',
                  borderRadius: '6px',
                  maxHeight: '400px',
                  overflow: 'auto'
                }}>
                  {selectedSongHistory.dates.length === 0 ? (
                    <div style={{ 
                      color: 'var(--text-muted)', 
                      fontStyle: 'italic',
                      textAlign: 'center',
                      padding: '1rem'
                    }}>
                      Never played in your setlist history
                    </div>
                  ) : (
                    selectedSongHistory.dates.map((show, i) => (
                      <div key={i} style={{
                        padding: '0.75rem',
                        borderBottom: i < selectedSongHistory.dates.length - 1 ? '1px solid var(--border)' : 'none',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center'
                      }}>
                        <div>
                          <div style={{ color: 'var(--text-primary)', fontWeight: '500' }}>
                            {(() => {
                              // Parse date as local time to avoid timezone shifts
                              const [year, month, day] = show.date.split('-');
                              return `${month}/${day}/${year.slice(-2)}`;
                            })()}
                          </div>
                          {show.city && (
                            <div style={{ 
                              fontSize: '0.85rem', 
                              color: 'var(--text-muted)',
                              marginTop: '0.25rem'
                            }}>
                              ðŸ“ {show.city}
                            </div>
                          )}
                        </div>
                      </div>
                    ))
                  )}
                </div>

                <button 
                  className="btn btn-secondary"
                  onClick={() => setSelectedSongHistory(null)}
                  style={{ width: '100%', marginTop: '1.5rem' }}
                >
                  Close
                </button>
              </div>
            </div>
          )}

          {/* Prediction Detail Modal */}
          {selectedPredictionDetail && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.8)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '2rem'
            }}>
              <div style={{
                background: 'var(--bg-card)',
                border: '2px solid var(--accent-purple)',
                borderRadius: '12px',
                padding: '1.5rem',
                maxWidth: '900px',
                width: '100%',
                maxHeight: '85vh',
                overflow: 'auto',
                position: 'relative'
              }}>
                {/* Header with Title, Score, and Close */}
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  marginBottom: '0.75rem'
                }}>
                  <div>
                    <h2 style={{ color: 'var(--accent-purple)', margin: 0, fontSize: '1.3rem' }}>
                      ðŸ“Š {selectedPredictionDetail.date} â€¢ {selectedPredictionDetail.city}
                    </h2>
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                    {/* Score Badge */}
                    <div style={{
                      padding: '0.5rem 1rem',
                      background: (() => {
                        const acc = parseInt(selectedPredictionDetail.accuracy);
                        if (acc >= 50) return 'rgba(34, 197, 94, 0.2)'; // Green
                        if (acc >= 20) return 'rgba(234, 179, 8, 0.2)'; // Yellow
                        return 'rgba(239, 68, 68, 0.2)'; // Red
                      })(),
                      border: (() => {
                        const acc = parseInt(selectedPredictionDetail.accuracy);
                        if (acc >= 50) return '2px solid rgb(34, 197, 94)'; // Green
                        if (acc >= 20) return '2px solid rgb(234, 179, 8)'; // Yellow
                        return '2px solid rgb(239, 68, 68)'; // Red
                      })(),
                      borderRadius: '6px',
                      textAlign: 'center'
                    }}>
                      <div style={{ 
                        fontSize: '1.3rem', 
                        fontWeight: '700',
                        color: (() => {
                          const acc = parseInt(selectedPredictionDetail.accuracy);
                          if (acc >= 50) return 'rgb(34, 197, 94)'; // Green
                          if (acc >= 20) return 'rgb(234, 179, 8)'; // Yellow
                          return 'rgb(239, 68, 68)'; // Red
                        })(),
                        lineHeight: '1'
                      }}>
                        {(() => {
                          const acc = parseInt(selectedPredictionDetail.accuracy);
                          const emoji = (acc >= 90) ? 'â­â­ðŸŽ¸ ' : '';
                          return `${emoji}${selectedPredictionDetail.matches}/10`;
                        })()}
                      </div>
                      <div style={{ 
                        fontSize: '0.7rem',
                        color: 'var(--text-muted)',
                        marginTop: '0.25rem'
                      }}>
                        {selectedPredictionDetail.accuracy}%
                      </div>
                    </div>
                    {/* Close Button */}
                    <button 
                      onClick={() => setSelectedPredictionDetail(null)}
                      style={{
                        background: 'none',
                        border: 'none',
                        color: 'var(--text-secondary)',
                        cursor: 'pointer',
                        fontSize: '0.9rem',
                        padding: '0.25rem 0.5rem',
                        textDecoration: 'underline'
                      }}
                    >
                      Close
                    </button>
                  </div>
                </div>

                {/* Run Info - Single Line */}
                {selectedPredictionDetail.runInfo && selectedPredictionDetail.runInfo.length > 0 && (
                  <div style={{
                    padding: '0.5rem 0.75rem',
                    background: 'rgba(255, 140, 66, 0.1)',
                    border: '1px solid var(--accent-orange)',
                    borderRadius: '6px',
                    marginBottom: '1rem',
                    fontSize: '0.8rem',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '0.5rem',
                    color: 'var(--text-secondary)'
                  }}>
                    <span style={{ color: 'var(--accent-orange)', fontWeight: '600' }}>ðŸ”— Multi-Night Run:</span>
                    <span>Nights {selectedPredictionDetail.runInfo.map(s => s.date).join(', ')}</span>
                    {selectedPredictionDetail.excludedSongs && selectedPredictionDetail.excludedSongs.length > 0 && (
                      <span style={{ marginLeft: 'auto', color: 'var(--text-muted)' }}>
                        â€¢ {selectedPredictionDetail.excludedSongs.length} songs excluded
                      </span>
                    )}
                  </div>
                )}
                
                {/* Two Column Layout */}
                <div style={{
                  display: 'grid',
                  gridTemplateColumns: '1fr 1fr',
                  gap: '1rem'
                }}>
                  {/* Predictions Column */}
                  <div>
                    <h3 style={{ 
                      color: 'var(--text-primary)', 
                      marginBottom: '0.5rem',
                      fontSize: '0.9rem',
                      fontWeight: '600',
                      borderBottom: '2px solid var(--accent-purple)',
                      paddingBottom: '0.25rem'
                    }}>
                      Top 10 Predictions
                    </h3>
                    <div style={{
                      background: 'var(--bg-dark)',
                      padding: '0.5rem',
                      borderRadius: '6px'
                    }}>
                      {selectedPredictionDetail.predictions.map((song, i) => {
                        const wasPlayed = selectedPredictionDetail.matchedSongs.includes(song);
                        return (
                          <div key={i} style={{
                            padding: '0.35rem 0.5rem',
                            marginBottom: '0.15rem',
                            background: wasPlayed ? 'rgba(34, 197, 94, 0.2)' : 'transparent',
                            border: wasPlayed ? '1px solid rgb(34, 197, 94)' : '1px solid transparent',
                            borderRadius: '4px',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.5rem',
                            fontSize: '0.85rem'
                          }}>
                            <span style={{ 
                              color: 'var(--text-muted)', 
                              fontSize: '0.75rem',
                              minWidth: '1.2rem'
                            }}>
                              {i + 1}.
                            </span>
                            <span style={{ 
                              color: wasPlayed ? 'rgb(34, 197, 94)' : 'var(--text-primary)',
                              fontWeight: wasPlayed ? '600' : 'normal',
                              flex: 1
                            }}>
                              {song}
                            </span>
                            {wasPlayed && (
                              <span style={{ fontSize: '0.85rem', color: 'rgb(34, 197, 94)' }}>âœ“</span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </div>

                  {/* Actual Setlist Column */}
                  <div>
                    <h3 style={{ 
                      color: 'var(--text-primary)', 
                      marginBottom: '0.5rem',
                      fontSize: '0.9rem',
                      fontWeight: '600',
                      borderBottom: '2px solid var(--accent-orange)',
                      paddingBottom: '0.25rem'
                    }}>
                      Actual Setlist ({selectedPredictionDetail.actualSongs.length} songs)
                    </h3>
                    <div style={{
                      background: 'var(--bg-dark)',
                      padding: '0.5rem',
                      borderRadius: '6px',
                      maxHeight: '400px',
                      overflow: 'auto'
                    }}>
                      {selectedPredictionDetail.actualSongs.map((song, i) => {
                        const wasPredicted = selectedPredictionDetail.matchedSongs.includes(song);
                        return (
                          <div key={i} style={{
                            padding: '0.35rem 0.5rem',
                            marginBottom: '0.15rem',
                            background: wasPredicted ? 'rgba(34, 197, 94, 0.2)' : 'transparent',
                            border: wasPredicted ? '1px solid rgb(34, 197, 94)' : '1px solid transparent',
                            borderRadius: '4px',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.5rem',
                            fontSize: '0.85rem'
                          }}>
                            <span style={{ 
                              color: wasPredicted ? 'rgb(34, 197, 94)' : 'var(--text-primary)',
                              fontWeight: wasPredicted ? '600' : 'normal',
                              flex: 1
                            }}>
                              {song}
                            </span>
                            {wasPredicted && (
                              <span style={{ fontSize: '0.85rem', color: 'rgb(34, 197, 94)' }}>âœ“</span>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Theme Edit Modal */}
          {editingTheme && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.8)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
              padding: '2rem'
            }}>
              <div style={{
                background: 'var(--bg-card)',
                border: '2px solid var(--accent-purple)',
                borderRadius: '12px',
                padding: '1.5rem',
                maxWidth: '700px',
                width: '100%',
                maxHeight: '85vh',
                overflow: 'auto'
              }}>
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  marginBottom: '1rem'
                }}>
                  <h2 style={{ color: 'var(--accent-purple)', margin: 0 }}>
                    Edit {editingTheme.label}
                  </h2>
                  <button 
                    onClick={cancelThemeEdit}
                    style={{
                      background: 'none',
                      border: 'none',
                      color: 'var(--text-secondary)',
                      cursor: 'pointer',
                      fontSize: '0.9rem',
                      textDecoration: 'underline'
                    }}
                  >
                    Close
                  </button>
                </div>

                {editingTheme.key === 'stateReferences' ? (
                  /* Special UI for State References */
                  <>
                    <div style={{ marginBottom: '1.5rem' }}>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Add State Reference
                      </label>
                      
                      <div style={{ display: 'grid', gridTemplateColumns: '1fr auto 1fr', gap: '0.5rem', alignItems: 'start', marginBottom: '0.5rem' }}>
                        {/* Song Search */}
                        <div style={{ position: 'relative' }}>
                          <label style={{ fontSize: '0.8rem', color: 'var(--text-muted)', marginBottom: '0.25rem', display: 'block' }}>
                            Song
                          </label>
                          <input
                            type="text"
                            placeholder={stateSong || "Search song..."}
                            value={stateSongSearch}
                            onChange={(e) => setStateSongSearch(e.target.value)}
                            style={{
                              width: '100%',
                              padding: '0.5rem',
                              background: stateSong ? 'rgba(59, 130, 246, 0.1)' : 'var(--bg-dark)',
                              border: stateSong ? '1px solid rgb(59, 130, 246)' : '1px solid var(--border)',
                              borderRadius: '6px',
                              color: 'var(--text-primary)',
                              fontSize: '0.9rem'
                            }}
                          />
                          {stateSong && !stateSongSearch && (
                            <button
                              onClick={() => { setStateSong(''); setStateSongSearch(''); }}
                              style={{
                                position: 'absolute',
                                right: '0.5rem',
                                top: '50%',
                                transform: 'translateY(-50%)',
                                background: 'none',
                                border: 'none',
                                color: 'var(--text-muted)',
                                cursor: 'pointer',
                                fontSize: '1rem',
                                padding: '0.25rem',
                                marginTop: '0.6rem'
                              }}
                            >
                              âœ•
                            </button>
                          )}
                          {stateSongSearch && !stateSong && (
                            <div style={{
                              position: 'absolute',
                              top: '100%',
                              left: 0,
                              right: 0,
                              zIndex: 1000,
                              background: 'var(--bg-card)',
                              border: '1px solid var(--border)',
                              borderRadius: '6px',
                              marginTop: '0.25rem',
                              maxHeight: '200px',
                              overflow: 'auto',
                              boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
                            }}>
                              {ALL_SONGS_WITH_COVERS
                                .filter(song => song.toLowerCase().includes(stateSongSearch.toLowerCase()))
                                .slice(0, 15)
                                .map(song => (
                                  <div
                                    key={song}
                                    onClick={() => {
                                      setStateSong(song);
                                      setStateSongSearch('');
                                    }}
                                    style={{
                                      padding: '0.5rem',
                                      cursor: 'pointer',
                                      borderBottom: '1px solid var(--border)',
                                      fontSize: '0.85rem'
                                    }}
                                    onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(59, 130, 246, 0.1)'}
                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                  >
                                    {song}
                                  </div>
                                ))}
                            </div>
                          )}
                        </div>

                        {/* Arrow */}
                        <div style={{ fontSize: '1.5rem', color: 'rgb(59, 130, 246)', paddingTop: '1.75rem', textAlign: 'center' }}>
                          â†’
                        </div>

                        {/* State Code Input */}
                        <div>
                          <label style={{ fontSize: '0.8rem', color: 'var(--text-muted)', marginBottom: '0.25rem', display: 'block' }}>
                            State Code
                          </label>
                          <input
                            type="text"
                            placeholder="GA, CA, TN..."
                            value={stateCode}
                            onChange={(e) => setStateCode(e.target.value.toUpperCase())}
                            maxLength={2}
                            style={{
                              width: '100%',
                              padding: '0.5rem',
                              background: 'var(--bg-dark)',
                              border: '1px solid var(--border)',
                              borderRadius: '6px',
                              color: 'var(--text-primary)',
                              fontSize: '0.9rem',
                              textTransform: 'uppercase'
                            }}
                          />
                        </div>
                      </div>

                      <button
                        onClick={addStateRefToTheme}
                        disabled={!stateSong || !stateCode}
                        className="btn btn-primary"
                        style={{
                          width: '100%',
                          opacity: (!stateSong || !stateCode) ? 0.5 : 1,
                          cursor: (!stateSong || !stateCode) ? 'not-allowed' : 'pointer'
                        }}
                      >
                        Add State Reference
                      </button>
                    </div>

                    {/* Current State References List */}
                    <div>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Current State References ({editingTheme.songs.length})
                      </label>
                      <div style={{
                        background: 'var(--bg-dark)',
                        border: '1px solid var(--border)',
                        borderRadius: '6px',
                        padding: '0.5rem',
                        maxHeight: '300px',
                        overflow: 'auto'
                      }}>
                        {editingTheme.songs.length === 0 ? (
                          <div style={{ 
                            padding: '1rem', 
                            textAlign: 'center', 
                            color: 'var(--text-muted)',
                            fontStyle: 'italic'
                          }}>
                            No state references yet. Add songs that mention states in their lyrics.
                          </div>
                        ) : (
                          editingTheme.songs.map(ref => {
                            const [song, state] = ref.split(':').map(s => s.trim());
                            return (
                              <div
                                key={ref}
                                style={{
                                  display: 'flex',
                                  justifyContent: 'space-between',
                                  alignItems: 'center',
                                  padding: '0.75rem',
                                  borderBottom: '1px solid var(--border)',
                                  gap: '0.5rem'
                                }}
                              >
                                <div style={{ flex: 1, display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.9rem' }}>
                                  <span>{song}</span>
                                  <span style={{ color: 'rgb(59, 130, 246)', fontWeight: '700' }}>â†’</span>
                                  <span style={{ color: 'rgb(59, 130, 246)' }}>ðŸ—ºï¸ {state}</span>
                                </div>
                                <button
                                  onClick={() => removeSongFromTheme(ref)}
                                  style={{
                                    background: 'rgba(239, 68, 68, 0.2)',
                                    border: '1px solid rgb(239, 68, 68)',
                                    color: 'rgb(239, 68, 68)',
                                    padding: '0.25rem 0.5rem',
                                    borderRadius: '4px',
                                    cursor: 'pointer',
                                    fontSize: '0.75rem',
                                    whiteSpace: 'nowrap'
                                  }}
                                >
                                  Remove
                                </button>
                              </div>
                            );
                          })
                        )}
                      </div>
                    </div>
                  </>
                ) : editingTheme.key === 'cityReferences' ? (
                  /* Special UI for City References */
                  <>
                    <div style={{ marginBottom: '1.5rem' }}>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Add City Reference
                      </label>
                      
                      <div style={{ display: 'grid', gridTemplateColumns: '1fr auto 1fr', gap: '0.5rem', alignItems: 'start', marginBottom: '0.5rem' }}>
                        {/* Song Search */}
                        <div style={{ position: 'relative' }}>
                          <label style={{ fontSize: '0.8rem', color: 'var(--text-muted)', marginBottom: '0.25rem', display: 'block' }}>
                            Song
                          </label>
                          <input
                            type="text"
                            placeholder={citySong || "Search song..."}
                            value={citySongSearch}
                            onChange={(e) => setCitySongSearch(e.target.value)}
                            style={{
                              width: '100%',
                              padding: '0.5rem',
                              background: citySong ? 'rgba(255, 140, 66, 0.1)' : 'var(--bg-dark)',
                              border: citySong ? '1px solid var(--accent-orange)' : '1px solid var(--border)',
                              borderRadius: '6px',
                              color: 'var(--text-primary)',
                              fontSize: '0.9rem'
                            }}
                          />
                          {citySong && !citySongSearch && (
                            <button
                              onClick={() => { setCitySong(''); setCitySongSearch(''); }}
                              style={{
                                position: 'absolute',
                                right: '0.5rem',
                                top: '50%',
                                transform: 'translateY(-50%)',
                                background: 'none',
                                border: 'none',
                                color: 'var(--text-muted)',
                                cursor: 'pointer',
                                fontSize: '1rem',
                                padding: '0.25rem',
                                marginTop: '0.6rem'
                              }}
                            >
                              âœ•
                            </button>
                          )}
                          {citySongSearch && !citySong && (
                            <div style={{
                              position: 'absolute',
                              top: '100%',
                              left: 0,
                              right: 0,
                              zIndex: 1000,
                              background: 'var(--bg-card)',
                              border: '1px solid var(--border)',
                              borderRadius: '6px',
                              marginTop: '0.25rem',
                              maxHeight: '200px',
                              overflow: 'auto',
                              boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
                            }}>
                              {ALL_SONGS_WITH_COVERS
                                .filter(song => song.toLowerCase().includes(citySongSearch.toLowerCase()))
                                .slice(0, 15)
                                .map(song => (
                                  <div
                                    key={song}
                                    onClick={() => {
                                      setCitySong(song);
                                      setCitySongSearch('');
                                    }}
                                    style={{
                                      padding: '0.5rem',
                                      cursor: 'pointer',
                                      borderBottom: '1px solid var(--border)',
                                      fontSize: '0.85rem'
                                    }}
                                    onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255, 140, 66, 0.1)'}
                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                  >
                                    {song}
                                  </div>
                                ))}
                            </div>
                          )}
                        </div>

                        {/* Arrow */}
                        <div style={{ fontSize: '1.5rem', color: 'var(--accent-orange)', paddingTop: '1.75rem', textAlign: 'center' }}>
                          â†’
                        </div>

                        {/* City Input */}
                        <div>
                          <label style={{ fontSize: '0.8rem', color: 'var(--text-muted)', marginBottom: '0.25rem', display: 'block' }}>
                            City
                          </label>
                          <input
                            type="text"
                            placeholder="Austin, Memphis..."
                            value={cityName}
                            onChange={(e) => setCityName(e.target.value)}
                            style={{
                              width: '100%',
                              padding: '0.5rem',
                              background: 'var(--bg-dark)',
                              border: '1px solid var(--border)',
                              borderRadius: '6px',
                              color: 'var(--text-primary)',
                              fontSize: '0.9rem'
                            }}
                          />
                        </div>
                      </div>

                      <button
                        onClick={addCityRefToTheme}
                        disabled={!citySong || !cityName}
                        className="btn btn-primary"
                        style={{
                          width: '100%',
                          opacity: (!citySong || !cityName) ? 0.5 : 1,
                          cursor: (!citySong || !cityName) ? 'not-allowed' : 'pointer'
                        }}
                      >
                        Add City Reference
                      </button>
                    </div>

                    {/* Current City References List */}
                    <div>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Current City References ({editingTheme.songs.length})
                      </label>
                      <div style={{
                        background: 'var(--bg-dark)',
                        border: '1px solid var(--border)',
                        borderRadius: '6px',
                        padding: '0.5rem',
                        maxHeight: '300px',
                        overflow: 'auto'
                      }}>
                        {editingTheme.songs.length === 0 ? (
                          <div style={{ 
                            padding: '1rem', 
                            textAlign: 'center', 
                            color: 'var(--text-muted)',
                            fontStyle: 'italic'
                          }}>
                            No city references yet. Add songs that mention cities in their lyrics.
                          </div>
                        ) : (
                          editingTheme.songs.map(ref => {
                            const [song, city] = ref.split(':').map(s => s.trim());
                            return (
                              <div
                                key={ref}
                                style={{
                                  display: 'flex',
                                  justifyContent: 'space-between',
                                  alignItems: 'center',
                                  padding: '0.75rem',
                                  borderBottom: '1px solid var(--border)',
                                  gap: '0.5rem'
                                }}
                              >
                                <div style={{ flex: 1, display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.9rem' }}>
                                  <span>{song}</span>
                                  <span style={{ color: 'var(--accent-orange)', fontWeight: '700' }}>â†’</span>
                                  <span style={{ color: 'var(--accent-orange)' }}>ðŸ“ {city}</span>
                                </div>
                                <button
                                  onClick={() => removeSongFromTheme(ref)}
                                  style={{
                                    background: 'rgba(239, 68, 68, 0.2)',
                                    border: '1px solid rgb(239, 68, 68)',
                                    color: 'rgb(239, 68, 68)',
                                    padding: '0.25rem 0.5rem',
                                    borderRadius: '4px',
                                    cursor: 'pointer',
                                    fontSize: '0.75rem',
                                    whiteSpace: 'nowrap'
                                  }}
                                >
                                  Remove
                                </button>
                              </div>
                            );
                          })
                        )}
                      </div>
                    </div>
                  </>
                ) : editingTheme.key === 'sequentialPairs' ? (
                  /* Special UI for Sequential Pairs */
                  <>
                    <div style={{ marginBottom: '1.5rem' }}>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Add New Pair
                      </label>
                      <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '0.5rem', position: 'relative' }}>
                        {/* Song A with independent search */}
                        <div style={{ flex: 1, position: 'relative' }}>
                          <input
                            type="text"
                            placeholder={pairSongA || "Search Song A..."}
                            value={pairSearchA}
                            onChange={(e) => setPairSearchA(e.target.value)}
                            onFocus={() => setPairSearchA('')}
                            style={{
                              width: '100%',
                              padding: '0.5rem',
                              background: pairSongA ? 'rgba(147, 51, 234, 0.1)' : 'var(--bg-dark)',
                              border: pairSongA ? '1px solid var(--accent-purple)' : '1px solid var(--border)',
                              borderRadius: '6px',
                              color: 'var(--text-primary)',
                              fontSize: '0.9rem'
                            }}
                          />
                          {pairSongA && !pairSearchA && (
                            <button
                              onClick={() => { setPairSongA(''); setPairSearchA(''); }}
                              style={{
                                position: 'absolute',
                                right: '0.5rem',
                                top: '50%',
                                transform: 'translateY(-50%)',
                                background: 'none',
                                border: 'none',
                                color: 'var(--text-muted)',
                                cursor: 'pointer',
                                fontSize: '1rem',
                                padding: '0.25rem'
                              }}
                            >
                              âœ•
                            </button>
                          )}
                          {pairSearchA && !pairSongA && (
                            <div style={{
                              position: 'absolute',
                              top: '100%',
                              left: 0,
                              right: 0,
                              zIndex: 1000,
                              background: 'var(--bg-card)',
                              border: '1px solid var(--border)',
                              borderRadius: '6px',
                              marginTop: '0.25rem',
                              maxHeight: '200px',
                              overflow: 'auto',
                              boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
                            }}>
                              {ALL_SONGS_WITH_COVERS
                                .filter(song => song.toLowerCase().includes(pairSearchA.toLowerCase()))
                                .slice(0, 15)
                                .map(song => (
                                  <div
                                    key={song}
                                    onClick={() => {
                                      setPairSongA(song);
                                      setPairSearchA('');
                                    }}
                                    style={{
                                      padding: '0.5rem',
                                      cursor: 'pointer',
                                      borderBottom: '1px solid var(--border)',
                                      fontSize: '0.85rem'
                                    }}
                                    onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(147, 51, 234, 0.1)'}
                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                  >
                                    {song}
                                  </div>
                                ))}
                            </div>
                          )}
                        </div>
                        
                        <div style={{ 
                          display: 'flex', 
                          alignItems: 'center',
                          color: 'var(--accent-purple)',
                          fontSize: '1.2rem',
                          fontWeight: '700'
                        }}>
                          â†”
                        </div>
                        
                        {/* Song B with independent search */}
                        <div style={{ flex: 1, position: 'relative' }}>
                          <input
                            type="text"
                            placeholder={pairSongB || "Search Song B..."}
                            value={pairSearchB}
                            onChange={(e) => setPairSearchB(e.target.value)}
                            onFocus={() => setPairSearchB('')}
                            style={{
                              width: '100%',
                              padding: '0.5rem',
                              background: pairSongB ? 'rgba(147, 51, 234, 0.1)' : 'var(--bg-dark)',
                              border: pairSongB ? '1px solid var(--accent-purple)' : '1px solid var(--border)',
                              borderRadius: '6px',
                              color: 'var(--text-primary)',
                              fontSize: '0.9rem'
                            }}
                          />
                          {pairSongB && !pairSearchB && (
                            <button
                              onClick={() => { setPairSongB(''); setPairSearchB(''); }}
                              style={{
                                position: 'absolute',
                                right: '0.5rem',
                                top: '50%',
                                transform: 'translateY(-50%)',
                                background: 'none',
                                border: 'none',
                                color: 'var(--text-muted)',
                                cursor: 'pointer',
                                fontSize: '1rem',
                                padding: '0.25rem'
                              }}
                            >
                              âœ•
                            </button>
                          )}
                          {pairSearchB && !pairSongB && (
                            <div style={{
                              position: 'absolute',
                              top: '100%',
                              left: 0,
                              right: 0,
                              zIndex: 1000,
                              background: 'var(--bg-card)',
                              border: '1px solid var(--border)',
                              borderRadius: '6px',
                              marginTop: '0.25rem',
                              maxHeight: '200px',
                              overflow: 'auto',
                              boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
                            }}>
                              {ALL_SONGS_WITH_COVERS
                                .filter(song => song.toLowerCase().includes(pairSearchB.toLowerCase()))
                                .slice(0, 15)
                                .map(song => (
                                  <div
                                    key={song}
                                    onClick={() => {
                                      setPairSongB(song);
                                      setPairSearchB('');
                                    }}
                                    style={{
                                      padding: '0.5rem',
                                      cursor: 'pointer',
                                      borderBottom: '1px solid var(--border)',
                                      fontSize: '0.85rem'
                                    }}
                                    onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(147, 51, 234, 0.1)'}
                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                  >
                                    {song}
                                  </div>
                                ))}
                            </div>
                          )}
                        </div>
                      </div>
                      <button
                        onClick={addPairToTheme}
                        disabled={!pairSongA || !pairSongB}
                        style={{
                          width: '100%',
                          padding: '0.5rem',
                          background: 'var(--accent-purple)',
                          border: 'none',
                          borderRadius: '6px',
                          color: 'white',
                          cursor: (!pairSongA || !pairSongB) ? 'not-allowed' : 'pointer',
                          fontSize: '0.9rem',
                          fontWeight: '600',
                          opacity: (!pairSongA || !pairSongB) ? 0.5 : 1
                        }}
                      >
                        Add Pair
                      </button>
                    </div>

                    {/* Current Pairs List */}
                    <div>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Current Pairs ({editingTheme.songs.length})
                      </label>
                      <div style={{
                        background: 'var(--bg-dark)',
                        border: '1px solid var(--border)',
                        borderRadius: '6px',
                        padding: '0.5rem',
                        maxHeight: '300px',
                        overflow: 'auto'
                      }}>
                        {editingTheme.songs.length === 0 ? (
                          <div style={{ 
                            padding: '1rem', 
                            textAlign: 'center', 
                            color: 'var(--text-muted)',
                            fontStyle: 'italic'
                          }}>
                            No pairs added yet. Add pairs above.
                          </div>
                        ) : (
                          editingTheme.songs.map((pair, idx) => {
                            const [songA, songB] = pair.split('<->');
                            return (
                              <div
                                key={idx}
                                style={{
                                  display: 'flex',
                                  justifyContent: 'space-between',
                                  alignItems: 'center',
                                  padding: '0.5rem',
                                  borderBottom: '1px solid var(--border)'
                                }}
                              >
                                <span style={{ fontSize: '0.9rem' }}>
                                  {songA} <span style={{ color: 'var(--accent-purple)', fontWeight: '700' }}>â†”</span> {songB}
                                </span>
                                <button
                                  onClick={() => removeSongFromTheme(pair)}
                                  style={{
                                    background: 'rgba(239, 68, 68, 0.2)',
                                    border: '1px solid rgb(239, 68, 68)',
                                    color: 'rgb(239, 68, 68)',
                                    padding: '0.25rem 0.5rem',
                                    borderRadius: '4px',
                                    cursor: 'pointer',
                                    fontSize: '0.75rem'
                                  }}
                                >
                                  Remove
                                </button>
                              </div>
                            );
                          })
                        )}
                      </div>
                    </div>
                  </>
                ) : (
                  /* Regular song list UI for other themes */
                  <>
                    {/* Search to Add Songs */}
                    <div style={{ marginBottom: '1.5rem' }}>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Add Song from Database
                      </label>
                      <input
                        type="text"
                        placeholder="ðŸ” Search songs..."
                        value={themeSearchTerm}
                        onChange={(e) => setThemeSearchTerm(e.target.value)}
                        style={{
                          width: '100%',
                          padding: '0.5rem',
                          background: 'var(--bg-dark)',
                          border: '1px solid var(--border)',
                          borderRadius: '6px',
                          color: 'var(--text-primary)',
                          fontSize: '0.9rem',
                          marginBottom: '0.5rem'
                        }}
                      />
                      {themeSearchTerm && (
                        <div style={{
                          background: 'var(--bg-dark)',
                          border: '1px solid var(--border)',
                          borderRadius: '6px',
                          maxHeight: '200px',
                          overflow: 'auto'
                        }}>
                          {ALL_SONGS_WITH_COVERS
                            .filter(song => song.toLowerCase().includes(themeSearchTerm.toLowerCase()))
                            .slice(0, 20)
                            .map(song => (
                              <div
                                key={song}
                                onClick={() => {
                                  addSongToTheme(song);
                                  setThemeSearchTerm('');
                                }}
                                style={{
                                  padding: '0.5rem',
                                  cursor: 'pointer',
                                  borderBottom: '1px solid var(--border)',
                                  transition: 'background 0.2s'
                                }}
                                onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(147, 51, 234, 0.1)'}
                                onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                              >
                                {song}
                                {editingTheme.songs.includes(song) && (
                                  <span style={{ marginLeft: '0.5rem', color: 'var(--accent-green)' }}>âœ“ Added</span>
                                )}
                              </div>
                            ))}
                        </div>
                      )}
                    </div>

                    {/* Current Songs List */}
                    <div>
                      <label style={{ 
                        display: 'block', 
                        marginBottom: '0.5rem',
                        fontSize: '0.9rem',
                        fontWeight: '600'
                      }}>
                        Current Songs ({editingTheme.songs.length})
                      </label>
                      <div style={{
                        background: 'var(--bg-dark)',
                        border: '1px solid var(--border)',
                        borderRadius: '6px',
                        padding: '0.5rem',
                        maxHeight: '300px',
                        overflow: 'auto'
                      }}>
                        {editingTheme.songs.length === 0 ? (
                          <div style={{ 
                            padding: '1rem', 
                            textAlign: 'center', 
                            color: 'var(--text-muted)',
                            fontStyle: 'italic'
                          }}>
                            No songs added yet. Search and add songs above.
                          </div>
                        ) : (
                          editingTheme.songs.map(song => (
                            <div
                              key={song}
                              style={{
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                padding: '0.5rem',
                                borderBottom: '1px solid var(--border)'
                              }}
                            >
                              <span>{song}</span>
                              <button
                                onClick={() => removeSongFromTheme(song)}
                                style={{
                                  background: 'rgba(239, 68, 68, 0.2)',
                                  border: '1px solid rgb(239, 68, 68)',
                                  color: 'rgb(239, 68, 68)',
                                  padding: '0.25rem 0.5rem',
                                  borderRadius: '4px',
                                  cursor: 'pointer',
                                  fontSize: '0.75rem'
                                }}
                              >
                                Remove
                              </button>
                            </div>
                          ))
                        )}
                      </div>
                    </div>
                  </>
                )}

                {/* Save/Cancel/Reset Buttons */}
                <div style={{ 
                  display: 'flex', 
                  gap: '0.5rem', 
                  marginTop: '1.5rem' 
                }}>
                  <button 
                    className="btn btn-primary"
                    onClick={saveThemeEdits}
                    style={{ flex: 1 }}
                  >
                    Save Changes
                  </button>
                  <button 
                    className="btn btn-secondary"
                    onClick={cancelThemeEdit}
                    style={{ flex: 1 }}
                  >
                    Cancel
                  </button>
                  <button 
                    onClick={async () => {
                      if (confirm('Reset this theme to default? Your custom edits will be lost.')) {
                        // Reload from GitHub to get defaults
                        try {
                          const response = await fetch('https://neilgolson.com/theme-songs.json');
                          if (response.ok) {
                            const themesData = await response.json();
                            const defaultSongs = themesData[editingTheme.key] || [];
                            
                            // Update editing state
                            setEditingTheme({
                              ...editingTheme,
                              songs: defaultSongs
                            });
                            
                            // Remove from localStorage edits
                            const localPrefs = JSON.parse(localStorage.getItem('panicSetlists') || '{}');
                            if (localPrefs.themeEdits && localPrefs.themeEdits[editingTheme.key]) {
                              delete localPrefs.themeEdits[editingTheme.key];
                              localStorage.setItem('panicSetlists', JSON.stringify(localPrefs));
                            }
                            
                            alert('âœ… Reset to default');
                          }
                        } catch (err) {
                          alert('Could not load defaults from GitHub');
                        }
                      }
                    }}
                    style={{
                      padding: '0.75rem',
                      background: 'rgba(239, 68, 68, 0.2)',
                      border: '1px solid rgb(239, 68, 68)',
                      color: 'rgb(239, 68, 68)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontSize: '0.85rem',
                      fontWeight: '600'
                    }}
                    title="Reset to GitHub defaults"
                  >
                    Reset
                  </button>
                </div>
              </div>
            </div>
          )}

          <header>
            <h1>Panic Setlist Predictor</h1>
            <p className="subtitle">Track the 3-show rule â€¢ Predict available songs â€¢ Live updates</p>
          </header>

          {/* Next Run Prediction / Tonight's Show Box */}
          <div className="card" style={{ 
            marginBottom: '2rem',
            background: mode === 'live' && liveSetlist.length > 0 
              ? 'linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(16, 185, 129, 0.1))'
              : 'linear-gradient(135deg, rgba(255, 51, 102, 0.1), rgba(255, 140, 66, 0.1))',
            borderColor: mode === 'live' && liveSetlist.length > 0 ? 'var(--accent-green)' : 'var(--accent-orange)'
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
              <h2 style={{ 
                color: mode === 'live' && liveSetlist.length > 0 ? 'var(--accent-green)' : 'var(--accent-red)', 
                margin: 0 
              }}>
                {mode === 'live' && liveSetlist.length > 0 ? 'ðŸŽ¸ Tonight\'s Show (Live)' : 'ðŸŽ¸ Next Run Prediction'}
              </h2>
              {(() => {
                const upcomingDate = '2026-02-14';
                const theme = getDateTheme(upcomingDate);
                if (!theme) return null;
                
                const themeLabels = {
                  valentine: { emoji: 'ðŸ’œ', label: 'Valentine\'s Day', color: 'rgb(147, 51, 234)' },
                  july4th: { emoji: 'ðŸŽ†', label: 'July 4th', color: 'rgb(239, 68, 68)' },
                  newyear: { emoji: 'ðŸŽ‰', label: 'New Year\'s', color: 'rgb(234, 179, 8)' }
                };
                
                const themeInfo = theme ? themeLabels[theme] : null;
                if (!themeInfo) return null;
                
                return (
                  <div style={{
                    padding: '0.5rem 1rem',
                    background: `${themeInfo.color}15`,
                    border: `1px solid ${themeInfo.color}`,
                    borderRadius: '6px',
                    fontSize: '0.85rem',
                    fontWeight: '500',
                    color: themeInfo.color,
                    whiteSpace: 'nowrap'
                  }}>
                    {themeInfo.emoji} {themeInfo.label}
                  </div>
                );
              })()}
            </div>
            <div style={{ display: 'grid', gridTemplateColumns: '2fr 3fr', gap: '2rem', alignItems: 'start' }}>
              <div>
                <div style={{ marginBottom: '1rem' }}>
                  <div style={{ 
                    fontSize: '1.8rem', 
                    fontFamily: "'Bebas Neue', sans-serif",
                    letterSpacing: '0.05em',
                    color: 'var(--accent-orange)',
                    marginBottom: '0.25rem'
                  }}>
                    February 14-15, 2026
                  </div>
                  <div style={{ fontSize: '1.2rem', color: 'var(--text-secondary)' }}>
                    ðŸ“ Moody Center, Austin, TX
                  </div>
                  <div style={{ 
                    fontSize: '0.9rem', 
                    color: 'var(--text-muted)',
                    marginTop: '0.5rem',
                    fontStyle: 'italic'
                  }}>
                    2-night run
                  </div>
                </div>
                
                <div style={{ marginTop: '1.5rem', paddingTop: '1.5rem', borderTop: '1px solid var(--border)' }}>
                  <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                    <label style={{ fontSize: '0.85rem', marginBottom: '0.25rem' }}>City/Location</label>
                    <input 
                      type="text"
                      placeholder="e.g., Savannah, Austin..."
                      value={nextRunCity}
                      onChange={e => setNextRunCity(e.target.value)}
                      style={{ 
                        width: '100%',
                        padding: '0.5rem',
                        background: 'var(--bg-dark)',
                        border: '1px solid var(--border)',
                        borderRadius: '6px',
                        color: 'var(--text-primary)',
                        fontSize: '0.9rem'
                      }}
                    />
                  </div>
                </div>
              </div>
              
              <div>
                {mode === 'live' && liveSetlist.length > 0 ? (
                  /* Live Show Mode - Show what's been played vs predicted */
                  <>
                    <h3 style={{ 
                      fontSize: '1rem',
                      color: 'var(--accent-green)',
                      marginBottom: '0.75rem',
                      textTransform: 'uppercase',
                      letterSpacing: '0.1em'
                    }}>
                      Songs Played Tonight ({liveSetlist.length})
                    </h3>
                    <div style={{ 
                      display: 'grid', 
                      gridTemplateColumns: '1fr',
                      gap: '0.5rem',
                      fontSize: '0.95rem',
                      marginBottom: '1.5rem'
                    }}>
                      {liveSetlist.map((song, i) => (
                        <div 
                          key={i}
                          style={{
                            padding: '0.5rem 0.75rem',
                            background: 'rgba(34, 197, 94, 0.1)',
                            border: '1px solid var(--accent-green)',
                            borderRadius: '6px',
                            color: 'var(--accent-green)',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                          }}
                        >
                          <span>{i + 1}. {song}</span>
                          <button
                            onClick={() => setLiveSetlist(liveSetlist.filter((_, idx) => idx !== i))}
                            style={{
                              background: 'none',
                              border: 'none',
                              color: 'var(--text-muted)',
                              cursor: 'pointer',
                              fontSize: '0.85rem',
                              padding: '0.25rem'
                            }}
                          >
                            âœ•
                          </button>
                        </div>
                      ))}
                    </div>
                    
                    <h3 style={{ 
                      fontSize: '1rem',
                      color: 'var(--text-secondary)',
                      marginBottom: '0.75rem',
                      textTransform: 'uppercase',
                      letterSpacing: '0.1em'
                    }}>
                      Top Remaining Predictions
                    </h3>
                  </>
                ) : (
                  <h3 style={{ 
                    fontSize: '1rem',
                    color: 'var(--text-secondary)',
                    marginBottom: '0.75rem',
                    textTransform: 'uppercase',
                    letterSpacing: '0.1em'
                  }}>
                    Top 10 Most Likely Songs
                  </h3>
                )}
                <div style={{ 
                  display: 'grid', 
                  gridTemplateColumns: '1fr 1fr',
                  gap: '0.5rem',
                  fontSize: '0.95rem'
                }}>
                  {(() => {
                    const upcomingCity = nextRunCity.toLowerCase().trim();
                    const upcomingDate = '2026-02-14'; // First night of the run
                    const runNights = 2; // 2-night run
                    
                    console.log('=== PREDICTION CALCULATION ===');
                    console.log('Total songs in songStatus:', Object.keys(songStatus).length);
                    
                    // Calculate likelihood score for each song
                    // Include songs available on EITHER night of the run
                    const scoredSongs = Object.entries(songStatus)
                      .filter(([song, status]) => {
                        const isInstrumental = song === 'Drums' || song === 'Jam';
                        const hasEnoughPlays = status.timesPlayed >= 2;
                        const availableNight1 = status.available;
                        const availableNight2 = status.showsSince === 2;
                        const passesFilter = !isInstrumental && hasEnoughPlays && (availableNight1 || availableNight2);
                        
                        if (song === 'Climb To Safety') {
                          console.log('Climb To Safety filter check:', {
                            isInstrumental,
                            timesPlayed: status.timesPlayed,
                            hasEnoughPlays,
                            showsSince: status.showsSince,
                            available: status.available,
                            availableNight1,
                            availableNight2,
                            passesFilter
                          });
                        }
                        
                        return passesFilter;
                      })
                      .map(([song, status]) => {
                        let score = 0;
                        
                        // Determine which night(s) this song is available
                        const availableNight1 = status.available;
                        const availableNight2 = status.showsSince === 2; // Currently resting (2 shows), becomes available on Night 2
                        const nightsAvailable = availableNight1 ? 'both' : 'night2';
                        
                        // Debug logging for songs that should be Night 2
                        if (song === 'Climb To Safety') {
                          console.log('Climb To Safety:', {
                            showsSince: status.showsSince,
                            available: status.available,
                            availableNight1,
                            availableNight2,
                            nightsAvailable,
                            timesPlayed: status.timesPlayed
                          });
                        }
                        
                        // Factor 1: Play frequency (0-50 points)
                        score += status.playFrequency * 0.5;
                        
                        // Factor 2: Favorite status (0-30 points)
                        if (heavyRotation.includes(song)) {
                          score += 30;
                        }
                        
                        // Factor 3: Time since last played (0-15 points, caps at 6 shows)
                        if (status.showsSince !== Infinity) {
                          score += Math.min(15, status.showsSince * 2.5);
                        }
                        
                        // Factor 4: City/State-specific bonus (0-30 points)
                        // Check both cityReferences and stateReferences
                        const cityRefs = themeSongs['cityReferences'] || [];
                        const stateRefs = themeSongs['stateReferences'] || [];
                        let isCityOrStateSong = false;
                        
                        // Check city references (Song:City format)
                        cityRefs.forEach(ref => {
                          const [songName, cityName] = ref.split(':').map(s => s.trim());
                          if (songName === song && upcomingCity.toLowerCase().includes(cityName.toLowerCase())) {
                            isCityOrStateSong = true;
                          }
                        });
                        
                        // Check state references (Song:STATE_CODE format)
                        stateRefs.forEach(ref => {
                          const [songName, stateCode] = ref.split(':').map(s => s.trim());
                          if (songName === song && upcomingCity.toLowerCase().includes(stateCode.toLowerCase())) {
                            isCityOrStateSong = true;
                          }
                        });
                        
                        if (isCityOrStateSong) {
                          score += 30;
                        }
                        
                        // Factor 5: Holiday/Theme bonus (0-30 points)
                        const currentTheme = getDateTheme(upcomingDate);
                        const themeList = currentTheme ? (themeSongs[currentTheme] || []) : [];
                        
                        const isThemeSong = themeList.includes(song);
                        if (isThemeSong) {
                          score += 30;
                        }
                        
                        // Factor 6: Night 2 availability bonus (0-15 points)
                        // Boost songs that become available on Night 2 so they appear in predictions
                        if (nightsAvailable === 'night2') {
                          score += 15;
                        }
                        
                        // RECALCULATE actual times played from setlists directly
                        const actualTimesPlayed = setlists.filter(setlist => 
                          setlist.songs.includes(song)
                        ).length;
                        
                        return { 
                          song, 
                          score, 
                          status: { ...status, timesPlayed: actualTimesPlayed }, 
                          isCity: isCityOrStateSong,
                          isTheme: isThemeSong,
                          theme: currentTheme,
                          nightsAvailable: nightsAvailable
                        };
                      })
                      .sort((a, b) => {
                        // First, sort by night availability (Night 1/both before Night 2)
                        if (a.nightsAvailable === 'both' && b.nightsAvailable === 'night2') return -1;
                        if (a.nightsAvailable === 'night2' && b.nightsAvailable === 'both') return 1;
                        
                        // Then by score
                        return b.score - a.score;
                      })
                      .slice(0, 10);
                    
                    console.log('Final top 10:', scoredSongs.map(s => ({ 
                      song: s.song, 
                      score: s.score, 
                      nights: s.nightsAvailable,
                      showsSince: s.status.showsSince 
                    })));
                    console.log('Night 2 songs:', scoredSongs.filter(s => s.nightsAvailable === 'night2').map(s => s.song));

                    if (scoredSongs.length === 0) {
                      return (
                        <div style={{ 
                          gridColumn: '1 / -1',
                          color: 'var(--text-muted)', 
                          fontSize: '0.9rem',
                          fontStyle: 'italic',
                          padding: '1rem'
                        }}>
                          Add some setlists to see predictions!
                        </div>
                      );
                    }

                    return scoredSongs.map(({ song, status, isCity, isTheme, theme, nightsAvailable }, i) => {
                      // Format last played date to MM/DD/YY
                      let lastPlayedFormatted = '';
                      if (status.lastPlayed && status.lastPlayed !== 'Tonight') {
                        // Parse date as local time to avoid timezone shifts
                        const [year, month, day] = status.lastPlayed.split('-');
                        lastPlayedFormatted = `${month}/${day}/${year.slice(-2)}`;
                      }

                      // Determine background color and border
                      let bgColor = 'var(--bg-dark)';
                      let borderColor = 'var(--accent-yellow)';
                      let icon = '';
                      
                      if (isTheme) {
                        bgColor = 'rgba(147, 51, 234, 0.15)'; // Purple for theme songs
                        borderColor = 'rgb(147, 51, 234)';
                        icon = theme === 'valentine' ? 'ðŸ’œ' : 
                               theme === 'july4th' ? 'ðŸŽ†' :
                               theme === 'newyear' ? 'ðŸŽ‰' : 'ðŸŽµ';
                      } else if (isCity) {
                        bgColor = 'rgba(255, 140, 66, 0.15)'; // Orange for city songs
                        borderColor = 'var(--accent-orange)';
                        icon = 'ðŸ“';
                      }

                      return (
                        <div key={i} style={{ 
                          padding: '0.5rem 0.75rem',
                          background: bgColor,
                          borderRadius: '6px',
                          borderLeft: `3px solid ${borderColor}`,
                          fontSize: '0.85rem',
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          gap: '0.5rem',
                          cursor: 'pointer',
                          transition: 'transform 0.1s ease'
                        }}
                        onClick={() => showSongHistory(song)}
                        onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.02)'}
                        onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}
                        >
                          <span style={{ flex: 1, minWidth: 0 }}>
                            {song}
                            {icon && <span style={{ marginLeft: '0.25rem' }}>{icon}</span>}
                            {nightsAvailable === 'night2' && (
                              <span style={{ 
                                marginLeft: '0.5rem',
                                fontSize: '0.65rem',
                                color: 'var(--accent-orange)',
                                fontWeight: '500'
                              }}>
                                N2
                              </span>
                            )}
                          </span>
                          <span style={{ 
                            fontSize: '0.7rem', 
                            color: 'var(--text-muted)',
                            fontStyle: 'italic',
                            whiteSpace: 'nowrap'
                          }}>
                            {lastPlayedFormatted || 'Never'}
                          </span>
                          <span style={{ 
                            fontSize: '0.7rem', 
                            color: 'var(--text-muted)',
                            whiteSpace: 'nowrap'
                          }}>
                            {Math.floor(status.timesPlayed)}x
                          </span>
                        </div>
                      );
                    });
                  })()}
                </div>
              </div>
            </div>
          </div>

          <div className="main-grid">
            {/* Left Column - Controls */}
            <div>
              <div className="card">
                <h2>Mode</h2>
                
                {/* Cloud Sync Status */}
                <div style={{
                  padding: '0.75rem',
                  marginBottom: '1rem',
                  background: 'rgba(34, 197, 94, 0.1)',
                  border: '1px solid var(--accent-green)',
                  borderRadius: '6px',
                  fontSize: '0.85rem',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '0.5rem'
                }}>
                  <span style={{ fontSize: '1rem' }}>â˜ï¸</span>
                  <div style={{ flex: 1 }}>
                    <div style={{ fontWeight: '600', color: 'var(--accent-green)' }}>
                      Synced from GitHub
                    </div>
                    <div style={{ fontSize: '0.75rem', color: 'var(--text-muted)', marginTop: '0.15rem' }}>
                      {setlists.length} shows â€¢ Themes synced â€¢ Your edits saved locally
                    </div>
                  </div>
                  <button
                    onClick={() => window.location.reload()}
                    style={{
                      padding: '0.35rem 0.75rem',
                      background: 'var(--accent-green)',
                      border: 'none',
                      borderRadius: '4px',
                      color: 'white',
                      fontSize: '0.75rem',
                      cursor: 'pointer',
                      fontWeight: '600'
                    }}
                    title="Reload page to get latest shows from GitHub"
                  >
                    Refresh
                  </button>
                </div>
                
                <div className="mode-toggle">
                  <button 
                    className={`mode-btn ${mode === 'setup' ? 'active' : ''}`}
                    onClick={() => setMode('setup')}
                  >
                    Add History
                  </button>
                  <button 
                    className={`mode-btn ${mode === 'live' ? 'active' : ''}`}
                    onClick={startLiveMode}
                  >
                    Live Show
                  </button>
                </div>

                {mode === 'setup' && (
                  <>
                    {editingSetlist && (
                      <div style={{ 
                        padding: '1rem', 
                        background: 'rgba(255, 140, 66, 0.1)', 
                        borderRadius: '6px',
                        marginBottom: '1rem',
                        border: '1px solid var(--accent-orange)'
                      }}>
                        <div style={{ fontSize: '0.9rem', color: 'var(--accent-orange)', marginBottom: '0.5rem' }}>
                          âœï¸ Editing Setlist
                        </div>
                      </div>
                    )}

                    <div className="input-group">
                      <label>Paste Setlist (Everyday Companion format supported)</label>
                      <textarea 
                        placeholder="Paste entire setlist from Everyday Companion or enter songs manually...
Example:
11/23/25 Fox Theater - Boulder, CO
Chilly Water, Pigeons, Space Wrangler..."
                        value={newSongs}
                        onChange={e => setNewSongs(e.target.value)}
                        style={{ minHeight: '200px' }}
                      />
                      <div className="help-text">
                        Paste from Everyday Companion (with date/venue) or type songs manually
                      </div>
                    </div>

                    {editingSetlist ? (
                      <div style={{ display: 'flex', gap: '0.5rem' }}>
                        <button className="btn btn-primary" onClick={saveEditedSetlist} style={{ flex: 1 }}>
                          Save Changes
                        </button>
                        <button className="btn btn-secondary" onClick={cancelEdit} style={{ flex: 1 }}>
                          Cancel
                        </button>
                      </div>
                    ) : (
                      <button className="btn btn-primary" onClick={addSetlist}>
                        Parse & Add Setlist
                      </button>
                    )}
                  </>
                )}

                {mode === 'live' && (
                  <>
                    <div className="live-indicator">
                      <span className="live-dot"></span>
                      Live Show in Progress
                    </div>

                    <div className="quick-add" style={{ position: 'relative' }}>
                      <input 
                        type="text"
                        placeholder="Search and add song to tonight's setlist..."
                        value={quickAdd}
                        onChange={e => setQuickAdd(e.target.value)}
                        onKeyPress={e => {
                          if (e.key === 'Enter' && quickAdd) {
                            const match = ALL_SONGS_WITH_COVERS.find(s => 
                              normalizeSongName(s).includes(normalizeSongName(quickAdd))
                            );
                            if (match) {
                              addSongToLive(match);
                              setQuickAdd('');
                            }
                          }
                        }}
                      />
                      {quickAdd && (
                        <div style={{
                          position: 'absolute',
                          top: '100%',
                          left: 0,
                          right: '80px',
                          zIndex: 1000,
                          background: 'var(--bg-card)',
                          border: '1px solid var(--border)',
                          borderRadius: '6px',
                          marginTop: '0.25rem',
                          maxHeight: '250px',
                          overflow: 'auto',
                          boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
                        }}>
                          {ALL_SONGS_WITH_COVERS
                            .filter(song => song.toLowerCase().includes(quickAdd.toLowerCase()))
                            .slice(0, 20)
                            .map(song => {
                              const status = songStatus[song];
                              const isAvailable = status?.available;
                              const isInSetlist = liveSetlist.includes(song);
                              
                              return (
                                <div
                                  key={song}
                                  onClick={() => {
                                    if (!isInSetlist) {
                                      addSongToLive(song);
                                      setQuickAdd('');
                                    }
                                  }}
                                  style={{
                                    padding: '0.5rem',
                                    cursor: isInSetlist ? 'not-allowed' : 'pointer',
                                    borderBottom: '1px solid var(--border)',
                                    fontSize: '0.85rem',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    opacity: isInSetlist ? 0.5 : 1
                                  }}
                                  onMouseEnter={(e) => !isInSetlist && (e.currentTarget.style.background = 'rgba(34, 197, 94, 0.1)')}
                                  onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                >
                                  <span>{song}</span>
                                  {isInSetlist ? (
                                    <span style={{ fontSize: '0.75rem', color: 'var(--accent-green)' }}>âœ“ Added</span>
                                  ) : !isAvailable ? (
                                    <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>Resting</span>
                                  ) : null}
                                </div>
                              );
                            })}
                        </div>
                      )}
                      <button 
                        className="btn btn-primary"
                        onClick={() => {
                          const match = ALL_SONGS_WITH_COVERS.find(s => 
                            normalizeSongName(s).includes(normalizeSongName(quickAdd))
                          );
                          if (match) {
                            addSongToLive(match);
                            setQuickAdd('');
                          }
                        }}
                      >
                        Add
                      </button>
                    </div>

                    <div style={{ marginBottom: '1rem' }}>
                      <strong>Tonight's Setlist ({liveSetlist.length} songs):</strong>
                      {liveSetlist.length > 0 ? (
                        <div style={{ marginTop: '0.5rem', fontSize: '0.9rem' }}>
                          {liveSetlist.map((song, i) => (
                            <div key={i} style={{ display: 'flex', justifyContent: 'space-between', padding: '0.25rem 0', borderBottom: '1px solid var(--border)' }}>
                              <span>{song}</span>
                              <button 
                                onClick={() => removeSongFromLive(song)}
                                style={{ background: 'none', border: 'none', color: 'var(--played)', cursor: 'pointer' }}
                              >
                                âœ•
                              </button>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <div style={{ color: 'var(--text-muted)', fontSize: '0.9rem', marginTop: '0.5rem' }}>
                          No songs added yet
                        </div>
                      )}
                    </div>

                    <button className="btn btn-primary" onClick={saveLiveSetlist}>
                      Save Tonight's Setlist
                    </button>
                    <button className="btn btn-secondary" onClick={() => setLiveSetlist([])}>
                      Clear
                    </button>
                  </>
                )}
              </div>

              {/* Recent Setlists - Last 4 */}
              <div className="card" style={{ marginTop: '2rem' }}>
                <h2>Recent Shows</h2>
                {setlists.length === 0 ? (
                  <div className="empty-state">
                    <div className="empty-state-icon">ðŸŽ¸</div>
                    <p>No setlists yet</p>
                    <p style={{ fontSize: '0.85rem' }}>Add your first show to get started</p>
                  </div>
                ) : (
                  <div>
                    {[...setlists]
                      .sort((a, b) => new Date(b.date) - new Date(a.date))
                      .slice(0, 4) // Only show last 4
                      .map((setlist, index) => {
                        return (
                          <div key={setlist.id} className="setlist-display">
                            <div className="setlist-header">
                              <span className="setlist-date">
                                {setlist.date}
                                {setlist.city && (
                                  <span style={{ marginLeft: '0.5rem', color: 'var(--accent-orange)' }}>
                                    ðŸ“ {setlist.city}
                                  </span>
                                )}
                              </span>
                            </div>
                            <div className="setlist-songs">
                              {setlist.songs.join(', ')}
                            </div>
                          </div>
                        );
                      })}
                  </div>
                )}
              </div>
            </div>

            {/* Right Column - Song List */}
            <div>
              <div className="card">
                <h2>Song Availability</h2>
                
                <div className="stats-grid">
                  <div className="stat-card">
                    <div className="stat-value">{stats.available}</div>
                    <div className="stat-label">Available</div>
                  </div>
                  <div className="stat-card">
                    <div className="stat-value">{stats.resting}</div>
                    <div className="stat-label">Resting</div>
                  </div>
                  <div className="stat-card">
                    <div className="stat-value">{stats.played}</div>
                    <div className="stat-label">Recently Played</div>
                  </div>
                </div>

                {/* Heavy Rotation Section - Top 20 Most Played */}
                {!searchTerm && heavyRotation.length > 0 && (
                  <>
                    <h3 style={{ 
                      fontFamily: "'Bebas Neue', sans-serif",
                      fontSize: '1.5rem',
                      color: 'var(--accent-yellow)',
                      marginBottom: '0.5rem',
                      borderBottom: '1px solid var(--border)',
                      paddingBottom: '0.5rem'
                    }}>
                      Heavy Rotation
                    </h3>
                    <div style={{ 
                      fontSize: '0.8rem', 
                      color: 'var(--text-muted)', 
                      marginBottom: '0.5rem',
                      fontStyle: 'italic'
                    }}>
                      Songs played 3+ times (Top 20 most frequently played)
                    </div>
                    <div className="song-list" style={{ maxHeight: '300px', marginBottom: '1.5rem' }}>
                      {heavyRotation.map(song => {
                        const status = songStatus[song];
                        if (!status) return null;
                        const statusClass = status.available ? 'available' : 
                                           status.showsSince === 0 ? 'played' : 'resting';
                        
                        return (
                          <div 
                            key={song} 
                            className={`song-item ${statusClass}`}
                            onClick={() => showSongHistory(song)}
                            style={{ cursor: 'pointer' }}
                          >
                            <span className="song-name">{song}</span>
                            <div className="song-status">
                              <span style={{ 
                                fontSize: '0.75rem', 
                                color: 'var(--accent-yellow)',
                                fontWeight: '600',
                                marginRight: '0.5rem'
                              }}>
                                {status.timesPlayed}x
                              </span>
                              {status.available ? (
                                <>
                                  <span className="status-badge available">Available</span>
                                  {status.lastPlayed && status.showsSince !== Infinity && (
                                    <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                      {status.showsSince} shows ago
                                    </span>
                                  )}
                                </>
                              ) : status.inCurrentRun ? (
                                <span className="status-badge resting">In Run</span>
                              ) : status.lastPlayed === 'Tonight' ? (
                                <span className="status-badge played">Tonight</span>
                              ) : status.showsSince === 0 ? (
                                <span className="status-badge played">Most Recent</span>
                              ) : status.showsSince === Infinity ? (
                                <span className="status-badge available">Never Played</span>
                              ) : (
                                <span className="status-badge resting">
                                  {status.showsSince === 1 ? '1 show ago' : 
                                   status.showsSince === 2 ? '2 shows ago' : 
                                   `${status.showsSince} shows ago`}
                                </span>
                              )}
                              {status.lastPlayed && status.lastPlayed !== 'Tonight' && (
                                <span style={{ fontSize: '0.75rem' }}>{status.lastPlayed}</span>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </>
                )}

                {/* Sort By - First */}
                <div className="input-group" style={{ marginBottom: '1rem' }}>
                  <label>Sort By</label>
                  <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
                    <option value="likelihood">Likelihood (Prediction Score)</option>
                    <option value="showsSince">Shows Since Last Played</option>
                    <option value="status">Availability Status</option>
                    <option value="timesPlayed">Most Times Played</option>
                    <option value="alpha">Alphabetical</option>
                  </select>
                </div>

                {/* Search Box - Second */}
                <div className="search-box">
                  <input 
                    type="text"
                    placeholder="ðŸ” Search songs..."
                    value={searchTerm}
                    onChange={e => setSearchTerm(e.target.value)}
                  />
                </div>

                <h3 style={{ 
                  fontFamily: "'Bebas Neue', sans-serif",
                  fontSize: '1.5rem',
                  color: 'var(--text-secondary)',
                  marginBottom: '0.5rem',
                  borderBottom: '1px solid var(--border)',
                  paddingBottom: '0.5rem'
                }}>
                  All Songs
                </h3>

                <div className="song-list">
                  {filteredSongs.map(song => {
                    const status = songStatus[song];
                    if (!status) return null;
                    const statusClass = status.available ? 'available' : 
                                       status.showsSince === 0 ? 'played' : 'resting';
                    
                    return (
                      <div 
                        key={song} 
                        className={`song-item ${statusClass}`}
                        onClick={() => showSongHistory(song)}
                        style={{ cursor: 'pointer' }}
                      >
                        <span className="song-name">{song}</span>
                        <div className="song-status">
                          {status.available ? (
                            <>
                              <span className="status-badge available">Available</span>
                              {status.lastPlayed && status.showsSince !== Infinity && (
                                <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                                  {status.showsSince} shows ago
                                </span>
                              )}
                            </>
                          ) : status.inCurrentRun ? (
                            <span className="status-badge resting">In Run</span>
                          ) : status.lastPlayed === 'Tonight' ? (
                            <span className="status-badge played">Tonight</span>
                          ) : status.showsSince === 0 ? (
                            <span className="status-badge played">Most Recent</span>
                          ) : status.showsSince === Infinity ? (
                            <span className="status-badge available">Never Played</span>
                          ) : (
                            <span className="status-badge resting">
                              {status.showsSince === 1 ? '1 show ago' : 
                               status.showsSince === 2 ? '2 shows ago' : 
                               `${status.showsSince} shows ago`}
                            </span>
                          )}
                          {status.timesPlayed > 0 && (
                            <span style={{ fontSize: '0.75rem', color: 'var(--text-muted)' }}>
                              {status.timesPlayed}x played
                            </span>
                          )}
                          {status.lastPlayed && status.lastPlayed !== 'Tonight' && (
                            <span style={{ fontSize: '0.75rem' }}>{status.lastPlayed}</span>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* All Shows Section */}
              <div className="card" style={{ marginTop: '2rem' }}>
                <h2>All Shows ({mode === 'live' && liveSetlist.length > 0 ? setlists.length + 1 : setlists.length})</h2>
                {setlists.length === 0 && !(mode === 'live' && liveSetlist.length > 0) ? (
                  <div className="empty-state">
                    <div className="empty-state-icon">ðŸŽ¸</div>
                    <p>No setlists yet</p>
                    <p style={{ fontSize: '0.85rem' }}>Add your first show to get started</p>
                  </div>
                ) : (
                  <div style={{ maxHeight: '600px', overflow: 'auto' }}>
                    {/* Tonight's Show (Live Mode) */}
                    {mode === 'live' && liveSetlist.length > 0 && (
                      <div className="setlist-display" style={{
                        background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(16, 185, 129, 0.1))',
                        border: '2px solid var(--accent-green)',
                        marginBottom: '1rem'
                      }}>
                        <div style={{ 
                          display: 'flex', 
                          justifyContent: 'space-between', 
                          alignItems: 'center',
                          marginBottom: '0.75rem'
                        }}>
                          <div>
                            <div style={{ 
                              fontSize: '1.1rem', 
                              fontWeight: '600',
                              color: 'var(--accent-green)',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '0.5rem'
                            }}>
                              <span style={{ fontSize: '1.3rem' }}>ðŸŽ¸</span>
                              Tonight's Show (Live)
                            </div>
                            <div style={{ 
                              fontSize: '0.85rem', 
                              color: 'var(--text-secondary)',
                              marginTop: '0.25rem'
                            }}>
                              {new Date().toLocaleDateString('en-US', { 
                                year: 'numeric', 
                                month: 'long', 
                                day: 'numeric' 
                              })}
                              {nextRunCity && (
                                <span> â€¢ {nextRunCity}</span>
                              )}
                            </div>
                          </div>
                        </div>
                        <div style={{ 
                          color: 'var(--text-primary)',
                          lineHeight: '1.6'
                        }}>
                          {liveSetlist.join(', ')}
                        </div>
                        <div style={{
                          marginTop: '0.75rem',
                          padding: '0.5rem',
                          background: 'rgba(34, 197, 94, 0.1)',
                          borderRadius: '4px',
                          fontSize: '0.85rem',
                          color: 'var(--accent-green)',
                          fontStyle: 'italic'
                        }}>
                          ðŸ’¡ This show will be saved when you click "Save Tonight's Setlist"
                        </div>
                      </div>
                    )}
                    
                    {/* Historical Shows */}
                    {[...setlists]
                      .sort((a, b) => new Date(b.date) - new Date(a.date))
                      .map((setlist, index) => {
                        const isEditing = editingSetlist === setlist.id;
                        
                        return (
                          <div key={setlist.id} className="setlist-display" style={{
                            background: isEditing ? 'rgba(255, 140, 66, 0.1)' : 'var(--bg-dark)',
                            border: isEditing ? '1px solid var(--accent-orange)' : '1px solid var(--border)'
                          }}>
                            {isEditing ? (
                              // Edit mode
                              <div>
                                <div style={{ marginBottom: '1rem', color: 'var(--accent-orange)', fontSize: '0.9rem' }}>
                                  âœï¸ Editing Setlist
                                </div>
                                <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                                  <label>Date</label>
                                  <input 
                                    type="date" 
                                    value={newDate}
                                    onChange={e => setNewDate(e.target.value)}
                                  />
                                </div>
                                <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                                  <label>Songs (comma-separated)</label>
                                  <textarea 
                                    value={newSongs}
                                    onChange={e => setNewSongs(e.target.value)}
                                    style={{ minHeight: '100px' }}
                                  />
                                </div>
                                <div className="input-group" style={{ marginBottom: '0.75rem' }}>
                                  <label>City/Location (optional)</label>
                                  <input 
                                    type="text"
                                    value={currentRun?.city || ''}
                                    onChange={e => setCurrentRun({ ...currentRun, city: e.target.value })}
                                    placeholder="e.g., Atlanta, GA"
                                  />
                                </div>
                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                  <button className="btn btn-primary" onClick={saveEditedSetlist} style={{ flex: 1 }}>
                                    Save Changes
                                  </button>
                                  <button className="btn btn-secondary" onClick={cancelEdit} style={{ flex: 1 }}>
                                    Cancel
                                  </button>
                                </div>
                              </div>
                            ) : (
                              // Display mode
                              <>
                                <div className="setlist-header">
                                  <span className="setlist-date">
                                    {setlist.date}
                                    {setlist.city && (
                                      <span style={{ marginLeft: '0.5rem', color: 'var(--accent-orange)' }}>
                                        ðŸ“ {setlist.city}
                                      </span>
                                    )}
                                    {showAccuracy[setlist.id] && (
                                      <span 
                                        onClick={() => {
                                          setSelectedPredictionDetail({
                                            date: setlist.date,
                                            city: setlist.city || 'Unknown',
                                            predictions: showAccuracy[setlist.id].predictions,
                                            actualSongs: showAccuracy[setlist.id].actualSongs,
                                            matchedSongs: showAccuracy[setlist.id].matchedSongs,
                                            matches: showAccuracy[setlist.id].matches,
                                            accuracy: showAccuracy[setlist.id].predictionAccuracy,
                                            runInfo: showAccuracy[setlist.id].runShows,
                                            excludedSongs: showAccuracy[setlist.id].songsPlayedInRun
                                          });
                                        }}
                                        style={{ 
                                        marginLeft: '0.75rem',
                                        padding: '0.25rem 0.5rem',
                                        background: (() => {
                                          const acc = parseInt(showAccuracy[setlist.id].predictionAccuracy);
                                          if (acc >= 50) return 'rgba(34, 197, 94, 0.2)'; // Green
                                          if (acc >= 20) return 'rgba(234, 179, 8, 0.2)'; // Yellow
                                          return 'rgba(239, 68, 68, 0.2)'; // Red
                                        })(),
                                        border: (() => {
                                          const acc = parseInt(showAccuracy[setlist.id].predictionAccuracy);
                                          if (acc >= 50) return '1px solid rgb(34, 197, 94)'; // Green
                                          if (acc >= 20) return '1px solid rgb(234, 179, 8)'; // Yellow
                                          return '1px solid rgb(239, 68, 68)'; // Red
                                        })(),
                                        borderRadius: '4px',
                                        fontSize: '0.75rem',
                                        fontWeight: '600',
                                        color: (() => {
                                          const acc = parseInt(showAccuracy[setlist.id].predictionAccuracy);
                                          if (acc >= 50) return 'rgb(34, 197, 94)'; // Green
                                          if (acc >= 20) return 'rgb(234, 179, 8)'; // Yellow
                                          return 'rgb(239, 68, 68)'; // Red
                                        })(),
                                        cursor: 'pointer',
                                        transition: 'transform 0.1s ease'
                                      }}
                                      onMouseEnter={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
                                      onMouseLeave={(e) => e.currentTarget.style.transform = 'scale(1)'}
                                      >
                                        {(() => {
                                          const acc = parseInt(showAccuracy[setlist.id].predictionAccuracy);
                                          const emoji = (acc >= 90) ? 'â­â­ðŸŽ¸ ' : 'ðŸ“Š ';
                                          return `${emoji}${showAccuracy[setlist.id].matches}/10 (${showAccuracy[setlist.id].predictionAccuracy}%)`;
                                        })()}
                                      </span>
                                    )}
                                  </span>
                                  <div style={{ display: 'flex', gap: '0.5rem' }}>
                                    <button 
                                      className="btn btn-secondary" 
                                      style={{ padding: '0.25rem 0.75rem', fontSize: '0.85rem' }}
                                      onClick={() => startEditingSetlist(setlist)}
                                    >
                                      Edit
                                    </button>
                                    <button 
                                      className="btn btn-secondary" 
                                      style={{ padding: '0.25rem 0.75rem', fontSize: '0.85rem' }}
                                      onClick={() => deleteSetlist(setlist.id)}
                                    >
                                      Delete
                                    </button>
                                  </div>
                                </div>
                                <div className="setlist-songs">
                                  {setlist.songs.join(', ')}
                                </div>
                              </>
                            )}
                          </div>
                        );
                      })}
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Theme Songs Editor */}
          <div style={{ 
            marginTop: '4rem', 
            paddingTop: '2rem', 
            borderTop: '2px solid var(--accent-purple)'
          }}>
            <h2 style={{
              fontFamily: "'Bebas Neue', sans-serif",
              fontSize: '2rem',
              color: 'var(--accent-purple)',
              marginBottom: '1rem',
              textAlign: 'center'
            }}>
              ðŸŽ­ Theme Song Lists
            </h2>
            <p style={{
              textAlign: 'center',
              color: 'var(--text-muted)',
              marginBottom: '2rem',
              fontSize: '0.9rem'
            }}>
              Customize which songs get bonuses for each holiday or theme
            </p>

            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
              gap: '1.5rem'
            }}>
              {Object.entries({
                valentine: { emoji: 'ðŸ’œ', label: 'Valentine\'s Day', color: 'rgb(147, 51, 234)', dateRange: 'Feb 10-18' },
                july4th: { emoji: 'ðŸŽ†', label: 'July 4th', color: 'rgb(239, 68, 68)', dateRange: 'Jun 30 - Jul 8' },
                newyear: { emoji: 'ðŸŽ‰', label: 'New Year\'s', color: 'rgb(234, 179, 8)', dateRange: 'Dec 28 - Jan 5' },
                cityReferences: { emoji: 'ðŸ“', label: 'City References', color: 'rgb(255, 140, 66)', dateRange: 'Format: Song:City' },
                stateReferences: { emoji: 'ðŸ—ºï¸', label: 'State References', color: 'rgb(59, 130, 246)', dateRange: 'Format: Song:STATE' },
                sequentialPairs: { emoji: 'ðŸ”—', label: 'Sequential Pairs', color: 'rgb(139, 92, 246)', dateRange: 'Format: Song A<->Song B' }
              }).map(([themeKey, themeInfo]) => (
                <div key={themeKey} style={{
                  background: 'var(--bg-dark)',
                  border: `2px solid ${themeInfo.color}`,
                  borderRadius: '12px',
                  padding: '1.5rem'
                }}>
                  <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: '0.5rem'
                  }}>
                    <h3 style={{
                      color: themeInfo.color,
                      margin: 0,
                      fontSize: '1.2rem',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '0.5rem'
                    }}>
                      <span style={{ fontSize: '1.5rem' }}>{themeInfo.emoji}</span>
                      {themeInfo.label}
                    </h3>
                    <button
                      onClick={() => startEditingTheme(themeKey, themeInfo.label)}
                      style={{
                        background: 'none',
                        border: `1px solid ${themeInfo.color}`,
                        color: themeInfo.color,
                        padding: '0.25rem 0.75rem',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '0.8rem',
                        fontWeight: '600'
                      }}
                    >
                      Edit
                    </button>
                  </div>
                  <div style={{
                    fontSize: '0.75rem',
                    color: 'var(--text-muted)',
                    marginBottom: '1rem',
                    fontStyle: 'italic'
                  }}>
                    {themeInfo.dateRange}
                  </div>
                  
                  <textarea
                    value={(themeSongs[themeKey] || []).join(', ')}
                    onChange={(e) => {
                      const songs = e.target.value
                        .split(',')
                        .map(s => s.trim())
                        .filter(s => s.length > 0);
                      setThemeSongs({
                        ...themeSongs,
                        [themeKey]: songs
                      });
                    }}
                    style={{
                      width: '100%',
                      minHeight: '120px',
                      background: 'var(--bg-light)',
                      border: '1px solid var(--border)',
                      borderRadius: '6px',
                      padding: '0.75rem',
                      color: 'var(--text-primary)',
                      fontFamily: 'inherit',
                      fontSize: '0.85rem',
                      resize: 'vertical'
                    }}
                    placeholder="Song 1, Song 2, Song 3..."
                  />
                  
                  <div style={{
                    marginTop: '0.75rem',
                    fontSize: '0.75rem',
                    color: 'var(--text-muted)',
                    fontStyle: 'italic'
                  }}>
                    {(themeSongs[themeKey] || []).length} songs â€¢ Comma-separated
                  </div>
                  
                  <button
                    className="btn btn-secondary"
                    onClick={() => {
                      if (confirm(`Reset ${themeInfo.label} to default list?`)) {
                        setThemeSongs({
                          ...themeSongs,
                          [themeKey]: DEFAULT_THEME_SONGS[themeKey]
                        });
                      }
                    }}
                    style={{
                      marginTop: '0.75rem',
                      width: '100%',
                      padding: '0.5rem',
                      fontSize: '0.85rem'
                    }}
                  >
                    Reset to Default
                  </button>
                </div>
              ))}
            </div>
          </div>

          {/* Data Management - Bottom of Page */}
          <div style={{ 
            marginTop: '4rem', 
            paddingTop: '2rem', 
            borderTop: '1px solid var(--border)',
            textAlign: 'center',
            display: 'flex',
            gap: '1rem',
            justifyContent: 'center',
            flexWrap: 'wrap'
          }}>
            <button 
              className="btn btn-primary"
              onClick={() => {
                // Show all dates with show counts
                const dateMap = {};
                setlists.forEach(setlist => {
                  const date = setlist.date;
                  if (!dateMap[date]) {
                    dateMap[date] = { count: 0, setlists: [] };
                  }
                  dateMap[date].count++;
                  dateMap[date].setlists.push(setlist);
                });
                
                const dates = Object.keys(dateMap).sort().reverse();
                let message = 'ðŸ“… ALL SHOW DATES IN DATABASE:\n\n';
                dates.forEach(date => {
                  const info = dateMap[date];
                  message += `${date} - ${info.count} setlist${info.count > 1 ? 's' : ''}\n`;
                  if (info.count > 1) {
                    message += `  âš ï¸ DUPLICATE! (${info.setlists.map(s => s.id).join(', ')})\n`;
                  }
                });
                
                alert(message);
              }}
              style={{ 
                background: '#0369a1', 
                borderColor: '#075985',
                padding: '0.75rem 2rem'
              }}
            >
              ðŸ“… Show All Dates
            </button>
            
            <button 
              className="btn btn-primary"
              onClick={() => {
                // Comprehensive export for analysis
                const exportData = {
                  exportDate: new Date().toISOString(),
                  totalShows: setlists.length,
                  setlists: [...setlists].sort((a, b) => new Date(a.date) - new Date(b.date)).map(s => ({
                    id: s.id,
                    date: s.date,
                    city: s.city || '',
                    venue: s.venue || '',
                    songs: s.songs
                  })),
                  themeSongs: themeSongs,
                  accuracyScores: Object.entries(showAccuracy)
                    .filter(([id, acc]) => acc !== null)
                    .map(([id, acc]) => {
                      const setlist = setlists.find(s => s.id === parseInt(id));
                      return {
                        showId: id,
                        date: setlist?.date,
                        city: setlist?.city,
                        matches: acc.matches,
                        totalPredicted: acc.totalPredicted,
                        totalPlayed: acc.totalPlayed,
                        predictionAccuracy: parseFloat(acc.predictionAccuracy),
                        coverage: parseFloat(acc.coverage)
                      };
                    }),
                  overallStats: {
                    totalAnalyzedShows: Object.values(showAccuracy).filter(a => a !== null).length,
                    totalCorrect: Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.matches, 0),
                    totalPredictions: Object.values(showAccuracy).filter(a => a !== null).length * 10,
                    totalPlayed: Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.totalPlayed, 0),
                    overallPredictionAccuracy: (Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.matches, 0) / 
                                               (Object.values(showAccuracy).filter(a => a !== null).length * 10) * 100).toFixed(2),
                    overallCoverage: (Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.matches, 0) / 
                                     Object.values(showAccuracy).filter(a => a !== null).reduce((sum, a) => sum + a.totalPlayed, 0) * 100).toFixed(2)
                  }
                };
                
                // Download as JSON
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `panic-data-export-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                
                alert(`ðŸ“Š Data Export Complete!\n\n` +
                      `Total Shows: ${exportData.totalShows}\n` +
                      `Analyzed Shows: ${exportData.overallStats.totalAnalyzedShows}\n` +
                      `Prediction Accuracy: ${exportData.overallStats.overallPredictionAccuracy}% (correct/10)\n` +
                      `Coverage: ${exportData.overallStats.overallCoverage}% (of total setlist)\n\n` +
                      `File downloaded as JSON for analysis.`);
              }}
              style={{ 
                background: '#7c3aed', 
                borderColor: '#6d28d9',
                padding: '0.75rem 2rem'
              }}
            >
              ðŸ“¤ Export for GitHub Update
            </button>
            
            <div style={{
              padding: '0.75rem',
              background: 'rgba(124, 58, 237, 0.1)',
              border: '1px solid rgba(124, 58, 237, 0.3)',
              borderRadius: '6px',
              fontSize: '0.8rem',
              color: 'var(--text-muted)',
              marginTop: '0.5rem'
            }}>
              ðŸ’¡ To add shows: Export â†’ Upload setlists.json to GitHub repo â†’ Everyone sees updates
            </div>
            
            <button 
              className="btn btn-primary"
              onClick={() => {
                if (confirm('ðŸ”§ Fix Data Issues\n\nThis will:\n- Remove duplicate songs from each setlist\n- Clean up any corrupted data\n- Keep all your setlists intact\n\nContinue?')) {
                  // Fix each setlist by deduplicating songs
                  const fixedSetlists = setlists.map(setlist => ({
                    ...setlist,
                    songs: [...new Set(setlist.songs)] // Remove duplicates
                  }));
                  
                  // Count how many songs were removed
                  const before = setlists.reduce((sum, s) => sum + s.songs.length, 0);
                  const after = fixedSetlists.reduce((sum, s) => sum + s.songs.length, 0);
                  const removed = before - after;
                  
                  setSetlists(fixedSetlists);
                  alert(`âœ… Data fixed!\n\nRemoved ${removed} duplicate song entries from your setlists.\n\nYour play counts should now be accurate.`);
                }
              }}
              style={{ 
                background: '#059669', 
                borderColor: '#047857',
                padding: '0.75rem 2rem'
              }}
            >
              ðŸ”§ Fix Duplicate Songs
            </button>
            
            <button 
              className="btn btn-secondary"
              onClick={() => {
                if (confirm('âš ï¸ DANGER ZONE âš ï¸\n\nThis will permanently delete ALL setlists, custom songs, and settings. This action cannot be undone.\n\nAre you absolutely sure?')) {
                  setSetlists([]);
                  setLiveSetlist([]);
                  setCustomSongs([]);
                  setEditingSetlist(null);
                  localStorage.clear();
                  alert('All data has been reset.');
                }
              }}
              style={{ 
                background: '#991b1b', 
                borderColor: '#7f1d1d',
                padding: '0.75rem 2rem'
              }}
            >
              ðŸ—‘ï¸ Reset All Data
            </button>
          </div>
          <div style={{ 
            fontSize: '0.75rem', 
            color: 'var(--text-muted)', 
            marginTop: '0.5rem',
            textAlign: 'center',
            fontStyle: 'italic'
          }}>
            Fix duplicates first â€¢ Reset deletes everything permanently
          </div>
        </div>
      );
    }

    ReactDOM.render(<PanicSetlistPredictor />, document.getElementById('root'));
  </script>
</body>
</html>
